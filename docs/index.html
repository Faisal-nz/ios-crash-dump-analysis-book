<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="by Faisal Memon" />
  <title>iOS Crash Dump Analysis</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="style/gitHubStyle.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">iOS Crash Dump Analysis</h1>
<p class="author">by Faisal Memon</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#quick-start">Quick Start</a><ul>
<li><a href="#troubleshooting-operating-environment-crashes">Troubleshooting operating environment crashes</a><ul>
<li><a href="#missing-resource-issue">Missing resource issue</a></li>
<li><a href="#binary-compatibility-issue">Binary compatibility issue</a></li>
<li><a href="#simulator-only-issue">Simulator only issue</a></li>
<li><a href="#site-specific-issues">Site specific issues</a></li>
<li><a href="#customer-device-deployment-issues">Customer device deployment issues</a></li>
<li><a href="#locale-specific-issues">Locale specific issues</a></li>
</ul></li>
<li><a href="#the-crash-mindset">The Crash Mindset</a></li>
</ul></li>
<li><a href="#basic-concepts">Basic Concepts</a><ul>
<li><a href="#what-is-a-crash">What is a crash?</a></li>
<li><a href="#operating-environment-policies">Operating Environment Policies</a><ul>
<li><a href="#nil-handling-example">Nil Handling Example</a></li>
<li><a href="#mac-address-example">MAC Address Example</a></li>
<li><a href="#camera-example">Camera Example</a></li>
<li><a href="#lessons-learnt">Lessons Learnt</a></li>
</ul></li>
<li><a href="#application-policies">Application policies</a><ul>
<li><a href="#when-should-you-crash">When should you crash?</a></li>
<li><a href="#when-should-you-not-crash">When should you not crash?</a></li>
</ul></li>
<li><a href="#engineering-guidance">Engineering Guidance</a><ul>
<li><a href="#unit-testing-the-mac-address">Unit Testing the MAC Address</a></li>
<li><a href="#ui-testing-camera-access">UI Testing Camera access</a></li>
</ul></li>
</ul></li>
<li><a href="#tooling">Tooling</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#reverse-engineering">Reverse Engineering</a></li>
<li><a href="#class-dump-tool">Class Dump Tool</a></li>
</ul></li>
<li><a href="#xcode-built-in-help">Xcode Built In Help</a><ul>
<li><a href="#xcode-diagnostic-settings">Xcode Diagnostic Settings</a><ul>
<li><a href="#execution-methodology">Execution Methodology</a></li>
<li><a href="#analysis-methodology">Analysis Methodology</a></li>
<li><a href="#process-methodology">Process Methodology</a></li>
</ul></li>
<li><a href="#the-middle-road">The Middle Road</a></li>
</ul></li>
<li><a href="#hybrid-environments">Hybrid Environments</a><ul>
<li><a href="#program-structure">Program structure</a></li>
<li><a href="#paradigms">Paradigms</a></li>
<li><a href="#the-problem">The Problem</a></li>
<li><a href="#solutions">Solutions</a><ul>
<li><a href="#stl-solution">STL Solution</a></li>
<li><a href="#facade-solution">Facade Solution</a></li>
</ul></li>
<li><a href="#lessons-learnt-1">Lessons Learnt</a></li>
</ul></li>
<li><a href="#symbolification">Symbolification</a><ul>
<li><a href="#build-process">Build Process</a></li>
<li><a href="#build-settings">Build Settings</a></li>
<li><a href="#observing-a-local-crash">Observing a local crash</a></li>
<li><a href="#dsym-structure">DSYM structure</a></li>
<li><a href="#manual-symbolification">Manual Symbolification</a></li>
<li><a href="#reverse-engineering-approach">Reverse Engineering Approach</a></li>
</ul></li>
<li><a href="#a-siri-crash">A Siri Crash</a><ul>
<li><a href="#why-are-we-looking-at-a-siri-crash">Why are we looking at a Siri Crash?</a></li>
<li><a href="#the-crash-report">The Crash report</a></li>
<li><a href="#the-crash-details">The Crash details</a></li>
<li><a href="#applying-our-tool-box">Applying our Tool Box</a></li>
<li><a href="#software-engineering-insights">Software Engineering Insights</a></li>
<li><a href="#lessons-learnt-2">Lessons Learnt</a></li>
</ul></li>
<li><a href="#bibliography">Bibliography</a></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>This book fills a gap that has emerged between Application Developers and the platform they are developing for when a crash occurs. The mindset of the Application developer is largely understanding high level concepts and abstractions. When a crash occurs, you can often feel rudely transported into a command line UNIX world of low level constructs, pointers and raw data.</p>
<p>We focus exclusively on the Apple ecosystem, and primarily the Swift programming language on iOS. We also cover macOS, tvOS, watchOS platforms, and C (CoreFoundation), Objective-C, and Objective-C++ programming languages. This is because the older languages are more prone to crash bugs. Real world applications tend to end up being a hybrid between the safer Swift language and older technologies.</p>
<p>We assume you have at least an introductory knowledge of iOS programming and software engineering, and have access to a Mac with Xcode.</p>
<p>The approach we take is to combine three different perspectives on the problem to give a rounded and robust view of the situation and how to resolve it.</p>
<p>Our three perspectives are:</p>
<ol type="1">
<li>A practical HOW-TO guide for using the excellent tooling available from Apple.</li>
<li>A discussion of software engineering concepts tailored to preventing and resolving crashes.</li>
<li>A formal problem-solving approach but applied to crash analysis.</li>
</ol>
<p>Programming literature comprehensively has documented software engineering concepts, and Apple has documented their crash dump tooling via Guides and WWDC videos.</p>
<p>Formal problem solving is less discussed in software engineering circles, perhaps because it’s considered a table stakes skill for an engineer. It is however a discipline of its own and when directly studied can only enhance the “natural” abilities that seem to mark out the “technically-minded” folks from the rest of the population.</p>
<p>Our goal is not the shy away from repeating knowledge we’ve probably seen or read elsewhere but instead we take the view point of explaining the whole narrative in a cohesive manner. What makes crash dump analysis hard is that significant background knowledge is often assumed in order to make room to concentrate on the particulars of a specific tool or crash report. That causes a barrier to entry which this book aims to overcome.</p>
<p>To complement the book, there is a website of resources which is intended to be used alongside the printed material so example projects can be setup and run by yourself and experimented with. All references in this book are collected into the Bibliography Chapter at the end of the book. There you will find URLs to resources for example.</p>
<p>The GitHub website supporting the book at <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<h1 id="quick-start">Quick Start</h1>
<p>When an application crash appears after a recent code change, it can be straightforward to reason about the crash and look at the relevant code changes. Often, crashes just appear due to a change in operating environment. Those can be the most annoying. For example, the app runs fine in the Office but crashes at the customer Site. You don’t have time to get into why, but need a quick fix or workaround. Another common problem is when a new project is being explored. This is where we have no past experience with the code base but immediately face crash problems after compilation and running the app.</p>
<p>In this chapter we explore possible reasons for crashing due to a change in operating environment. There are a variety of problems that can be dealt with without getting into logical analysis of the specifics of the problem at hand. In reality sometimes you just need to make progress, whilst making a note to go back and address the root cause.</p>
<h2 id="troubleshooting-operating-environment-crashes">Troubleshooting operating environment crashes</h2>
<h3 id="missing-resource-issue">Missing resource issue</h3>
<p>Sometimes your app crashes on startup due to a missing resource issue.</p>
<p>Try compiling and running other Xcode targets within the same project. Sometimes a specific target is the one that sets up your environment as part of the build. If so, make a note to address that later.</p>
<h3 id="binary-compatibility-issue">Binary compatibility issue</h3>
<p>Sometimes your app crashes on startup due to a binary compatibility issue.</p>
<p>If you’ve recently updated Xcode, or pulled code updates on top of a compiled project, do a Option-Command-Shift-K clean which cleans the build area of intermediates, and then re-build as normal.</p>
<h3 id="simulator-only-issue">Simulator only issue</h3>
<p>Somtimes your app crashes only on simulator.</p>
<p>Try Simulator Hardware-&gt;Reset all content and settings. Try iPad simulator instead of iPhone simulator and vice-versa. Sample projects are often used to explain a particular technology without regard to productisation or generality.</p>
<h3 id="site-specific-issues">Site specific issues</h3>
<p>Sometimes your app only crashes when at customer site.</p>
<p>Check Wi-Fi settings or try hot-spotting your iPad to iPhone. Sometimes network issues such as connectivity, or latency are overlooked when developing your app in your office/home environment. Make a note to fix networking assumptions if that is the problem.</p>
<h3 id="customer-device-deployment-issues">Customer device deployment issues</h3>
<p>Sometimes your app only crashes when deploying on a customer device gives problems.</p>
<p>If you cable up your laptop to the customer’s device, you’re probably doing a Debug release deployment. This means push notification tokens will be the development tokens not the production tokens. It also may mean that resource access grants (to Camera for example) are no longer valid as they may have been approved via a TestFlight or App Store version of the app previously (production version).</p>
<p>Try switching deployment configuration via Command-&lt; select Run in the left panel, Info tab in the right panel, Build Configuration setting Release (not Debug). Also manually check any resource access grants in the iPad/iPhone settings.</p>
<h3 id="locale-specific-issues">Locale specific issues</h3>
<p>Sometimes deploying with the customer’s locale causes a crash.</p>
<p>Resource files might be absent in the wrong locale. Furthermore, locale handling is rife with undocumented special cases. Try changing the locale temporarily to a known working one. Make a note to return to the issue when back in the office.</p>
<h2 id="the-crash-mindset">The Crash Mindset</h2>
<p>One take away lesson from the above examples are that we need to think of our code in a wider context. Think of the operating environment for your app. This comprises:</p>
<ul>
<li>the compiled code</li>
<li>binary incompatibilities between code modules (different language versions, compilers and toolchains)</li>
<li>resource files bundled or downloaded into the app</li>
<li>the build configuration (e.g. Release or Debug)</li>
<li>the network environment, availability/latency/speed</li>
<li>permissions granted to the app</li>
<li>permissions denied to the app (in a Mobile Device Managment secured environment)</li>
<li>platform variants</li>
<li>orientation</li>
<li>foreground and background operating modes</li>
<li>hardware performance (old slow hardware versus faster newer devices)</li>
<li>hardware components (GPU, Memory, CPU, accessories, etc.)</li>
<li>geographic location related issues</li>
<li>locale issues</li>
<li>presence of diagnostics settings</li>
<li>presence of a debugger or profiler</li>
<li>the OS version of the target device</li>
</ul>
<p>As a first step in getting into the correct mindset to tackle app crashes, its worthwhile working through each of the above operating environment differences and trying to note down if such a difference ever resulted in a crash that you know about or suspect could happen. This will teach you that crashes are much more about <strong>environment</strong> than about <strong>source code</strong>. Another secondary insight is that the more able you are to produce a list of hypotheses given a specific environment difference, the more easily and quickly you will be able to find the root cause of crashes that seem mysterious to other people, and almost magical that you came up with a suggestion of where the problem could be.</p>
<p>Here are some curious examples of crashes from the Information Technology folklore to whet your appetite and get you thinking:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Trigger for Crash</th>
<th>Reason for crash</th>
<th>Historical Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Locale</td>
<td>Only Russian locale caused a crash during date processing. This was because 1984-04-01 was being used as a sentinel date marker. However, in Russia, there is no such date/time because there is no midnight at that point in time. Daylight time started in Russia on that date with a +1 hour.</td>
<td>This was seen during development of the WecudosPro iPad app when it was tested in Russia</td>
</tr>
<tr class="even">
<td>Geographic Location</td>
<td>A computer was crashing each day; each time a different reason. The actual problem was the computer was near a window next to a estuary where ships passed by. At high tide, a military ship would sail past and its RADAR would disrupt the electronics and cause a crash.</td>
<td>This folklore story was told to Sun Microsystems Answer Center engineers in the UK during Kepner-Tregoe formal problem solving training.</td>
</tr>
<tr class="odd">
<td>Bus Noise</td>
<td>When a computer was under both heavy network load and disk load the system would crash to due corruption on disk. There was always a zero very 64 bytes. It was the cache line size of the computer. The memory board was not wired up correctly causing noise at 64 byte boundaries picked up by the disk ribbon cable sitting next to it.</td>
<td>This was seen during the development of Sun Volume Systems Group prototype hardware build.</td>
</tr>
</tbody>
</table>
<h1 id="basic-concepts">Basic Concepts</h1>
<h2 id="what-is-a-crash">What is a crash?</h2>
<p>An application crash is something the Operating Environment does to your application in response to what you have done (or failed to do) in the Operating Environment that violates some <em>policy</em> of the platform you are running on.</p>
<h2 id="operating-environment-policies">Operating Environment Policies</h2>
<p>The policies of the operating environment are there to ensure security, data safety, performance, and privacy of the environment to the user.</p>
<h3 id="nil-handling-example">Nil Handling Example</h3>
<p>Newcomers to the Apple ecosystem are often surprised to learn that Objective-C allows you to message a nil object. It silently ignores the failed dispatch. For example the following method runs ok.</p>
<pre><code>- (void)nilDispatchDoesNothing
{
    NSString *error = NULL;
    assert([error length] == 0);
}</code></pre>
<p>The Objective-C runtime authors made a judgement call, and decided it was better for an application to ignore such problems.</p>
<p>However if you deference a C pointer you get a crash.</p>
<pre><code>void nullDereferenceCrash() {
    char *nullPointer = NULL;
    assert(strlen(nullPointer) == 0);
}</code></pre>
<p>The authors of the operating system have setup the system so access to this and other low memory addresses causes the hardware to trap on this illegal access and abort your program.</p>
<p>This area of memory is set aside by the operating system because it indicates a programming error of not setting up an object or data structure properly.</p>
<p>When things go wrong, you don’t always get a crash. Only if it is Operating Environment policy then you get a crash.</p>
<h3 id="mac-address-example">MAC Address Example</h3>
<p>Consider the example of getting the MAC address of your iPhone. The Media Access Control (MAC) address is a unique code allocated to network cards to allow machines to talk to each other without duplication at the Data Link layer of the communication stack.</p>
<p>Prior to iOS 7, the MAC address was not considered a sensitive API. So requesting the MAC address using the <code>sysctl</code> API gave the real address. To see this in action, see the <code>icdab_sample</code> app <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span>.</p>
<p>Unfortunately, the API was abused as a way of tracking the user - a privacy violation. Therefore Apple introduced a policy from iOS 7 where they would return a fixed MAC address always.</p>
<p>Apple could have chosen to crash your app when any call to <code>sysctl</code> was made. However, <code>sysctl</code> is a general purpose low level call which can be used for other valid purposes. Therefore the policy set by iOS was to return you a fixed MAC address <code>02:00:00:00:00:00</code> whenever that was requested.</p>
<h3 id="camera-example">Camera Example</h3>
<p>Now lets consider the case of taking a photo using the camera.</p>
<p>Introduced in iOS 10, when you want to access the Camera, a privacy sensitive feature, you need to define human readable text that is presented inside the system permission dialogue before access to the Camera is granted.</p>
<p>If you don’t define the text in your <code>Info.plist</code> for <code>NSCameraUsageDescription</code> you still the following code returning true and then attempting to present the image picker.</p>
<pre><code>if UIImagePickerController
            .isSourceTypeAvailable(UIImagePickerControllerSourceType.camera) {
            let imagePicker = UIImagePickerController()
            imagePicker.delegate = self
            imagePicker.sourceType = UIImagePickerControllerSourceType.camera
            imagePicker.allowsEditing = false
            self.present(imagePicker, animated: true, completion: nil)
        }</code></pre>
<p>However when you run the code you see a crash with a descriptive console message:</p>
<pre><code>2018-07-10 20:09:21.549897+0100 icdab_sample[1775:15601294]
 [access] This app has crashed because it attempted to access
  privacy-sensitive data without a usage description.  
  The app&#39;s Info.plist must contain an NSCameraUsageDescription
   key with a string value explaining to the user how the app
   uses this data.
Message from debugger: Terminated due to signal 9</code></pre>
<h3 id="lessons-learnt">Lessons Learnt</h3>
<p>Note the contrast here. In both cases there was a privacy sensitive API. But in the camera case, Apple chose a policy of crashing your app instead of giving a warning, allowing a boilerplate standard explanation dialog, or returning a <code>false</code> value to indicate the source type was not available.</p>
<p>This underlies the point about there being two entities involved, the program and the operating environment (which includes its policies). Having correct source code does not guarantee crash free running. And when we see a crash we need to think about the operating environment as much as the code itself.</p>
<h2 id="application-policies">Application policies</h2>
<p>It’s not just the Operating Environment that can define a policy for when to crash. The application you are writing can also request a crash. This is typically done via <code>assert</code> calls in your code. These calls ask the Operating Environment to terminate your app if the assert has failed. The Operating Environment then aborts your app. In the crash report you get a</p>
<p><code>Exception Type:  EXC_CRASH (SIGABRT)</code></p>
<p>to indicate it was the application that requested the crash in the first place.</p>
<h3 id="when-should-you-crash">When should you crash?</h3>
<p>You can apply similar standards as the Operating Environment for your crash policy.</p>
<p>If your code detects a data integrity issue, you could crash to prevent further data corruption.</p>
<h3 id="when-should-you-not-crash">When should you not crash?</h3>
<p>If the problems have resulted directly from some IO problem (file or network access for example) or some human input problem (such as a bad date value) then you should not crash.</p>
<p>It’s your job as the application developer to shield the lower level parts of the system from unpredictability present in the real world. Such problems are better dealt with by logging, error handling, user alerts, and IO retries.</p>
<h2 id="engineering-guidance">Engineering Guidance</h2>
<p>How should we guard against the privacy problems described above?</p>
<p>The thing to keep in mind is that any code that touches upon the policies the Operating Environment has guards for is a good candidate for automated testing.</p>
<p>In the <code>icdab_sample</code> project we have created Unit tests and UI tests.</p>
<p>Test cases always feel over-the-top when applied to trivial programs. But consider a large program which has an extensive <code>Info.plist</code> file. A new version of the app is called for so another <code>Info.plist</code> is created. Then keeping the privilege settings in sync between the different build targets becomes an issue. The UI test code shown here which merely launches the camera can catch such problems easily so has practical business value.</p>
<p>Similarly if your app has a lot of low level code and then is ported from iOS to tvOS for example, how much of that OS-sensitive code is still applicable?</p>
<p>Unit testing a top level function comprehensively for different design concerns can pay off the effort invested in it before delving deeper and unit testing the underlying helper function calls in your code base. Its a strategic play allowing you to get some confidence in your application and early feedback on problem areas when porting to other platforms within the Apple Ecosystem (and beyond).</p>
<h3 id="unit-testing-the-mac-address">Unit Testing the MAC Address</h3>
<p>The code to get the MAC address is not trivial. So it merits some level of testing.</p>
<p>Here is a snippet from the Unit tests:</p>
<pre><code>    func getFirstOctectAsInt(_ macAddress: String) -&gt; Int {
        let firstOctect = macAddress.split(separator: &quot;:&quot;).first!
        let firstOctectAsNumber = Int(String(firstOctect))!
        return firstOctectAsNumber
    }

    func testMacAddressNotNil() {
        let macAddress = MacAddress().getMacAddress()
        XCTAssertNotNil(macAddress)
    }

    func testMacAddressIsNotRandom() {
        let macAddressFirst = MacAddress().getMacAddress()
        let macAddressSecond = MacAddress().getMacAddress()
        XCTAssert(macAddressFirst == macAddressSecond)
    }

    func testMacAddressIsUnicast() {
        let macAddress = MacAddress().getMacAddress()!
        let firstOctect = getFirstOctectAsInt(macAddress)
        XCTAssert(0 == (firstOctect &amp; 1))
    }

    func testMacAddressIsGloballyUnique() {
        let macAddress = MacAddress().getMacAddress()!
        let firstOctect = getFirstOctectAsInt(macAddress)
        XCTAssert(0 == (firstOctect &amp; 2))
    }</code></pre>
<p>In fact, the last test fails because the OS returns a local address.</p>
<h3 id="ui-testing-camera-access">UI Testing Camera access</h3>
<p>For testing camera access we have written a simple UI test case which just presses the Take Photo button (by means of an accessibility identifier <code>takePhotoButton</code>)</p>
<pre><code>func testTakePhoto() {
    let app = XCUIApplication()
    app.buttons[&quot;takePhotoButton&quot;].tap()
}</code></pre>
<p>This UI test code caused an immediate crash.</p>
<h1 id="tooling">Tooling</h1>
<h2 id="overview">Overview</h2>
<p>We have a rich set of tools available to assist crash dump analysis. When used properly they can save a huge amount of time.</p>
<p>Xcode provides much help out of the box. But using and comprehending the information Xcode tools provide is daunting. In later chapters we go through examples showing the use of such tools.</p>
<p>Additionally there are command line tools provided as standard in macOS. These are helpful when used in particular usage scenarios when you already know what you want to find out. We shall go through specific scenarios and show how the tools are used.</p>
<p>Next come software tools that help you reverse engineer programs. Sometimes you cannot get your program to work with a third party library. Aside from looking at Documentation or raising a Support Request, it’s possible to do some investigation yourself using these tools.</p>
<h2 id="reverse-engineering">Reverse Engineering</h2>
<p>Reverse engineering is where you take an already built binary (such as an application, library, or helper process daemon), and work out how it was engineered to work. For example:</p>
<ul>
<li>what are the lifecycles of the objects it is provided?</li>
<li>what checks does it do on objects?</li>
<li>what files or resources does it depend on?</li>
<li>why did it return a failure code?</li>
</ul>
<p>You generally do not want to know everything, only something specific to help build a hypothesis which you will test related to the crash dump you are dealing with.</p>
<p>How far should you go with reverse engineering and how much money and time to invest in it is a good question. We offer the following recommendation.</p>
<ul>
<li>If you are just starting your application developer journey or you have limited funds, then just stick with the standard Xcode tooling, macOS command line, and the open source class-dump tool.</li>
<li>If you are a professional application developer, strongly consider buying a commercial reverse engineering tool. The one that draws most attention is Hopper; it provides a lot of functionality offered by IDA Pro (a high end tool). It is well priced and can pay for itself in gained productivity even if only used a handful of times. We show how Hopper can be used in this book.</li>
<li>If you are a professional penetration tester, reverse engineer, or security researcher, then you will be probably wanting to invest in the top of the line software tool, IDA Pro. The tool costs thousands but is often purchased as an company wide expense.</li>
</ul>
<h2 id="class-dump-tool">Class Dump Tool</h2>
<p>One of the great things about the Objective-C runtime is that it carries lots of rich program structure information in its built binaries. These allow the dynamic aspects of the language to work. In fact its flexibility of dynamic dispatch is a source for many crashes.</p>
<p>We recommend installing the <code>class-dump</code> tool right away because we shall reference its usage in later chapters. See <span class="citation" data-cites="class-dump-tool">Nygard (2018)</span></p>
<p>The class dump tool allows us to look at what Objective C classes, methods and properties are present in a given program.</p>
<h1 id="xcode-built-in-help">Xcode Built In Help</h1>
<p>Xcode provides a lot of help to developers in understanding and preventing crashes.</p>
<p>We think of Xcode in layers of sophistication, where at the lowest layer of sophistication Xcode directly tells you the common error it has seen with suggested corrections, up to the highest level were Xcode is telling the raw information, but you need Operating Systems knowledge to interpret the information yourself.</p>
<p>We shall revisit Xcode configuration, setup and tooling many times. But let us first start off with the simple but high value assistance Xcode provides.</p>
<h2 id="xcode-diagnostic-settings">Xcode Diagnostic Settings</h2>
<p>By opening the project <code>icdab_sample</code> <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span> and looking at the Schema definition and then highlighting the Diagnostics tab we see the following options:</p>
<p><img src="screenshots/diagnostic_settings.png" /></p>
<h3 id="execution-methodology">Execution Methodology</h3>
<p>If you have a crash which is reproducible from your own developer environment and source code, then a methodology for finding is to switch on the appropriate diagnostic setting and then re-run your application.</p>
<p>As you become familiar with each diagnostic, you will know which option to switch on. We shall work through different scenarios so you understand when to use each. But when you are just starting out its worth just going through each one-by-one to get a feel for what is available. The basic approach is:</p>
<ol type="1">
<li>Write a Unit Test Case or UI Test Case that hits the problem.</li>
<li>Enable just one of the Diagnostic options from above starting with your best guess.</li>
<li>Run your tests.</li>
<li>Take note of any warning or console message from Xcode.</li>
<li>Repeat again but choosing a different diagnostic option if the problem is not understood.</li>
</ol>
<h3 id="analysis-methodology">Analysis Methodology</h3>
<p>Another complementary approach for analysing and proactively avoiding crashes is to run the Code Analyser. This is invoked using Command-Shift-B</p>
<p>In the sample app <code>icdab_sample</code> the Analyser reports:</p>
<pre><code>/Users/faisalm/dev/icdab/source/icdab_sample/icdab_sample/macAddress.m:22:12:
 warning: Null pointer argument in call to string length function
    assert(strlen(nullPointer) == 0);</code></pre>
<p>and conveniently marks up your source code</p>
<p><img src="screenshots/analyser_null.png" /></p>
<p>This can be switched on for whenever the project is Built, either in shallow or deep mode according to how you feel the tradeoff should be done between slower more thorough analysis versus quicker build times with less analysis. It is in the Build Settings tab for the Xcode project file.</p>
<p><img src="screenshots/static_analyser_build.png" /></p>
<p>For a large project that has never had an Analysis report done, the output can be overwhelming. There will be some noise in the report but it generally does a good job. There will be duplication in the report because certain classes of error will repeat throughout the code.</p>
<p>If you are developing code using the Agile software methodology, then it is possible to frame the report as potential backlog items that can be worked upon during the time allocated for refactoring and maintenance.</p>
<p>In a large software project refactoring and maintenance should be around 20% of the work in a Sprint. Different viewpoints arise in this area. The author recommends doing such work alongside the normal development activities so long as no high risk changes are amongst the work being done. For risky changes, leave that till after a major update of the app has been done. There is usually a lull where planning and strategy is developed following a release which allows a convenient software engineering window to tackle such matters.</p>
<h4 id="ios-quickedit-app-case-study">iOS QuickEdit App Case Study</h4>
<p>Where the analyser identifies potential crashes, from an economic point of view it is good investment to fix the problem. For example in the case of the QuickEdit iOS App, about 1 million lines of Objective-C, with 70 000 daily active users, the analyser was run and found 13 clear crashing issues. We created one engineering story (“Fix top analyser errors”). All 13 issues were fixed in the same day with testing taking two more days. Crashes are a top complaint from customers. Bugs found in the field typically are 20 times the effort and cost compared those found in development. With a large population of users, potentially experiencing a severe crash bug, the cost of those 13 bugs could be 20 * 3 days = 60 days wasted effort.</p>
<p>QuickEdit due to its age only used manual reference counting in Objective-C. Despite this it had a reliability of 99.5% based on app analytics. Only about 5% of engineering effort was needed to maintain this stability over time once the initial issues had been addressed.</p>
<h3 id="process-methodology">Process Methodology</h3>
<p>One way to drive out crashes from your app, particularly when you are in a large organisation, is to factor it in your software development process.</p>
<p>When a developer proposes a code change in a pull request, get the developer to ensure no new analyser warnings are introduced. You might consider the analyser report as a robotically generated code review available to you for free. That is particularly helpful if you are working alone on a project with no peer to review your code.</p>
<p>When code is committed to a feature branch, have the automated tests run on it, with different diagnostics settings set. This can shake out problems automatically.</p>
<p>Before each release, schedule time to run some specific user cases under the memory profiler (Xcode instruments will be covered later on) to look at memory usage or other key metrics. Record the highlights such as the peak memory usage as well as the profile file. Then when the following release is made you have a yardstick to see how things have changed both quantitatively and qualitatively.</p>
<h2 id="the-middle-road">The Middle Road</h2>
<p>Most software developers know what they “should” be doing; clean code, proper tests, code reviews, etc.</p>
<p>We recommend to take a measured approach. There is a time for hacking together a sample app to understand a concept. There is a time to write a prototype which just needs to prove a business use case. There is a time to write heavily trusted code used by many people.</p>
<p>We take the view that maximising economic impact is the one that matters most because most developers are involved in professional software development. Alternatively if you are working on non-commercial projects or hobby projects, the economic cost is really your personal free time which you will want to use most effectively.</p>
<p>We recommend:</p>
<ul>
<li>For Sample apps and concept exploration, just code the app.</li>
<li>For Prototype Development, just use the Execution Methodology when you hit problems.</li>
<li>For Individual Product Development, from the beginning run the Analyser automatically and informally incorporate it into your workflow when you see something important. From the beginning write tests but selectively where you get big impact.</li>
<li>For Team-based Product Development, add in the Process Methodology. Start becoming comprehensive with Testing.</li>
</ul>
<h1 id="hybrid-environments">Hybrid Environments</h1>
<p>We have seen that Xcode offers many automatic facilities for crash dump analysis and crash avoidance. But these can not get us all the answers we need. A complementary design oriented viewpoint is needed.</p>
<p>In this chapter we shall look at a sample app <code>icdab_planets</code> which uses hybrid of programming languages and paradigms. It shows an example of why design insights must also be considered.</p>
<h2 id="program-structure">Program structure</h2>
<p>The <code>icdab_planets</code> sample app uses a mixture of C++, and Objective-C++. It relies on both STL data structures and traditional Objective-C data structures. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<p>The model layer of the app is written in C++. The controller layer of the app is written in Objective-C++.</p>
<p>The purpose of the app is to tell you how many Pluto sized planets would fit inside Jupiter.</p>
<h2 id="paradigms">Paradigms</h2>
<p>Recall earlier we contrasted between Objective-C allowing messaging to nil objects versus C which crashes upon NULL dereference. Here we show how the C++ Standard Template Library has a back-fill strategy.</p>
<p>In the STL map abstraction (a Hash Table) when you query for an entry which does not exist, the STL will insert a new entry in the table for the key being queried, and then return you that entry instead of returning an error or returning a nil.</p>
<h2 id="the-problem">The Problem</h2>
<p>In our sample app, which crashes upon launch, we have an assert that gets triggered.</p>
<pre><code>double pluto_volume = pluto.get_volume();
assert(pluto_volume != 0.0);

double plutos_to_fill_jupiter =  jupiter.get_volume() / pluto_volume;</code></pre>
<p>Enabling code Analysis will not find any issue or warning.</p>
<p>The assert is in place to avoid a division by zero. That fact that it is triggered is good because we know where to start debugging the problem.</p>
<p>Pluto’s volume is 0.0 because the code <code>planet pluto = planet::get_planet_with_name(&quot;Pluto&quot;);</code> returns a planet with zero diameter.</p>
<p>From the file <code>planet_data.hpp</code> we see the API that we rely upon is:</p>
<pre><code>static planet get_planet_with_name(string name);</code></pre>
<p>So whatever name we pass in, we should always get a <code>planet</code> in response. Never a NULL.</p>
<p>The problem is that this API has not been thought deeply about. It has just been put together as a thin wrapper around the underlying abstractions that do the work.</p>
<p>We have</p>
<pre><code>planet planet::get_planet_with_name(string name) {
    if (!database.loaded_data) {
        database.load_data();
    }
    return database.planets[name];
}</code></pre>
<p>At first glance it might be that the database failed to load data properly. In actual fact, the database is missing the entry for Pluto due to:</p>
<pre><code>void planet_database::load_data() {
    planet planet_Mercury = planet(&quot;Mercury&quot;, 4878.0, 57.9 * millionKm);
    planets[&quot;Mercury&quot;] = planet_Mercury;

    planet planet_Venus = planet(&quot;Venus&quot;, 12104, 108.2 * millionKm);
    planets[&quot;Venus&quot;] = planet_Venus;

    planet planet_Earth = planet(&quot;Earth&quot;, 12756, 149.6 * millionKm);
    planets[&quot;Earth&quot;] = planet_Earth;

    planet planet_Mars = planet(&quot;Mars&quot;, 6792, 227.9 * millionKm);
    planets[&quot;Mars&quot;] = planet_Mars;

    planet planet_Jupiter = planet(&quot;Jupiter&quot;, 142984, 778 * millionKm);
    planets[&quot;Jupiter&quot;] = planet_Jupiter;

    planet planet_Saturn = planet(&quot;Saturn&quot;, 120536, 1427 * millionKm);
    planets[&quot;Saturn&quot;] = planet_Saturn;

    planet planet_Uranus = planet(&quot;Uranus&quot;, 51118, 2870 * millionKm);
    planets[&quot;Uranus&quot;] = planet_Uranus;

    planet planet_Neptune = planet(&quot;Neptune&quot;, 49532, 4497 * millionKm);
    planets[&quot;Neptune&quot;] = planet_Neptune;

//  No longer considered a planet but instead a dwarf planet
//  planet planet_Pluto = planet(&quot;Pluto&quot;, 2370, 7375 * millionKm);
//  planets[&quot;Pluto&quot;] = planet_Pluto;

    loaded_data = true;
}</code></pre>
<p>The problem indirectly is because <code>database.planets[name]</code> discovered that there was no entry for Pluto so created one via the no-arg constructor as this is the behaviour for STL map data structures.</p>
<pre><code>planet::planet() {
    this-&gt;name = &quot;&quot;;
    this-&gt;diameter = 0.0;
    this-&gt;distance_from_sun = 0.0;
}</code></pre>
<p>We see the constructor makes the diameter zero in this case.</p>
<h2 id="solutions">Solutions</h2>
<p>We see that the problem is not applying the paradigms of each framework and language properly and when you have a mixture of paradigms those different assumptions get masked by each layer of abstraction.</p>
<p>In STL, we expect a <code>find</code> operation to be done, instead of the indexing operator. This allows the abstraction to flag the absence of the item being found.</p>
<p>In Objective-C we expect the lookup API to be a function which returns an index given the lookup name. And the index would be <code>NSNotFound</code> when the operation failed.</p>
<p>In this code example, each layer of abstraction assumes the other side will re-map the edge case into an appropriate form.</p>
<h3 id="stl-solution">STL Solution</h3>
<p>We have a variant of the code which does things “properly” from an STL point of view. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span> It is <code>example/planets_stl</code>. On the consumer side, we have a helper method:</p>
<pre><code>- (BOOL)loadPlanetData {
    auto pluto_by_find = planet::find_planet_named(&quot;Pluto&quot;);
    auto jupiter_by_find = planet::find_planet_named(&quot;Jupiter&quot;);

    if (planet::isEnd(jupiter_by_find) || planet::isEnd(pluto_by_find)) {
        return NO;
    }
    pluto = pluto_by_find-&gt;second;
    jupiter = jupiter_by_find-&gt;second;
    return YES;
}</code></pre>
<p>This is is hard to parse if you are mainly an Objective-C programmer. If the project is mainly a C++ project with a thin platform-specific layer then perhaps that is acceptable. If the code base just leverages C++ code from elsewhere, then a better solution is to confine the paradigms to their own files and apply the facade design pattern to give a version of the API following Objective-C paradigms on the platform-specific code side.</p>
<p>Then Objective-C++ can be dispensed with in the ViewController code; it can be made an Objective-C file instead.</p>
<h3 id="facade-solution">Facade Solution</h3>
<p>Here is a facade implementation <code>example/facade_planets</code> that overcomes the mixing of paradigms problem.</p>
<p>The facade is:</p>
<pre><code>@implementation PlanetModel

- (id)init {
    self = [super init];

    NSString *testSupportAddPluto = [[[NSProcessInfo processInfo] environment]
                                     objectForKey:@&quot;AddPluto&quot;];

    if ([testSupportAddPluto isEqualToString:@&quot;YES&quot;]) {
        planet::add_planet(planet(&quot;Pluto&quot;, 2370, 7375 * millionKm));
    }

    if (self) {
        _planetDict = [[NSMutableDictionary alloc] init];
        auto pluto_by_find = planet::find_planet_named(&quot;Pluto&quot;);
        auto jupiter_by_find = planet::find_planet_named(&quot;Jupiter&quot;);

        if (planet::isEnd(jupiter_by_find) || planet::isEnd(pluto_by_find)) {
            return nil;
        }
        auto pluto = pluto_by_find-&gt;second;
        auto jupiter = jupiter_by_find-&gt;second;

        PlanetInfo *plutoPlanet = [[PlanetInfo alloc] init];
        plutoPlanet.diameter = pluto.get_diameter();
        plutoPlanet.distanceFromSun = pluto.get_distance_from_sun();
        plutoPlanet.volume = pluto.get_volume();
        assert (plutoPlanet.volume != 0.0);
        [_planetDict setObject:plutoPlanet forKey:@&quot;Pluto&quot;];

        PlanetInfo *jupiterPlanet = [[PlanetInfo alloc] init];
        jupiterPlanet.diameter = jupiter.get_diameter();
        jupiterPlanet.distanceFromSun = jupiter.get_distance_from_sun();
        jupiterPlanet.volume = jupiter.get_volume();
        assert (jupiterPlanet.volume != 0.0);
        [_planetDict setObject:jupiterPlanet forKey:@&quot;Jupiter&quot;];
    }

    return self;
}

@end</code></pre>
<p>The consumer then becomes a purely Objective-C class:</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    self.planetModel = [[PlanetModel alloc] init];

    if (self.planetModel == nil) {
        return;
    }

    double pluto_diameter = self.planetModel.planetDict[@&quot;Pluto&quot;].diameter;
    double jupiter_diameter = self.planetModel.planetDict[@&quot;Jupiter&quot;].diameter;
    double plutoVolume = self.planetModel.planetDict[@&quot;Pluto&quot;].volume;
    double jupiterVolume = self.planetModel.planetDict[@&quot;Jupiter&quot;].volume;
    double plutosInJupiter = jupiterVolume/plutoVolume;

    self.plutosInJupiterLabelOutlet.text =
    [NSString stringWithFormat:@&quot;Number of Plutos that fit inside Jupiter = %f&quot;,
     plutosInJupiter];

    self.jupiterLabelOutlet.text =
    [NSString stringWithFormat:@&quot;Diameter of Jupiter (km) = %f&quot;,
     jupiter_diameter];
    self.plutoLabelOutlet.text =
    [NSString stringWithFormat:@&quot;Diameter of Pluto (km) = %f&quot;,
     pluto_diameter];
}</code></pre>
<h2 id="lessons-learnt-1">Lessons Learnt</h2>
<p>The lesson here is that crashes can arise from special case handling. Since different languages and frameworks deal with special cases in their own idiomatic manner, it is safer to separate out your code and use a Facade if possible to keep each paradigm cleanly separated.</p>
<h1 id="symbolification">Symbolification</h1>
<p>This chapter explains crash dump symbolification. We use the <code>icdab_planets</code> sample app to demonstrate a crash. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<p>When dealing with real world crashes, a number of different entities are involved. These can be the end user device, the settings allowing the crash report to be sent back to Apple, the symbols held by Apple and your local development environment setup to mirror such a configuration.</p>
<p>In order to understand how things all fit together it is best to start from first principles and do the data conversion tasks yourself so if you have to diagnose symbolification issues, you have some experience with the technologies at hand.</p>
<h2 id="build-process">Build Process</h2>
<p>Normally when you develop an app, you are deploying the Debug version of your app onto your device. When you are deploying your app for testers, app review, or app store release, you are deploying the Release version of your app.</p>
<p>In both scenarios debug information is placed into the binary being generated. This is called DWARF debugging information.</p>
<p>For Release builds, that information is then stripped out and placed into a DSYM file. For Debug builds, it is left in.</p>
<p>The debugger can use debugging information in the binary when it sees a crash to help us understand where the program has gone wrong.</p>
<p>When a user sees your program crash, there is no debugger. Instead, a crash report is generated. This comprises the machine addresses where the problem was seen. A later phase, called symbolification, can convert the addresses into meaningful source code references so long as an appropriate DSYM file exists.</p>
<p>Xcode is by default setup so that only DSYM files are generated for Release builds, and not for Debug builds.</p>
<p>The reason why Debug builds just use the application binary with all the debug information built in is that the information is always available and consistent with the rest of the binary. However it makes the binary much larger and allows reverse engineers to peek into your binary quite easily as if you had published the source code together with the program.</p>
<h2 id="build-settings">Build Settings</h2>
<p>From Xcode, in your build settings, searching for “Debug Information Format” we see the following settings:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Setting</th>
<th>Meaning</th>
<th>Usually set for target</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DWARF</td>
<td>Debugging information built into the binary itself</td>
<td>Debug</td>
</tr>
<tr class="even">
<td>DWARF with dSYM File</td>
<td>We get an extra file also generated with symbols</td>
<td>Release</td>
</tr>
</tbody>
</table>
<p>In the default setup, if you run your debug binary on your device, launching it from the app icon itself then if it were to crash you would not have any symbols in the crash report. This confuses many people.</p>
<p>Whilst you may have all the source code for your program, and DWARF data in the crashed binary, ReportCrash crash reporter only looks for DSYM files on your Mac in order to perform symbolification.</p>
<p>To avoid this problem, the sample app <code>icdab_planets</code> has been configured to have <code>DWARF with dSYM File</code> set for both debug and release targets.</p>
<h2 id="observing-a-local-crash">Observing a local crash</h2>
<p>The <code>icdab_planets</code> program is designed to crash upon launch due to an assertion.</p>
<p>If the <code>DWARF with dSYM File</code> setting had not been made, we would get a partially symbolicated crash.</p>
<p>The crash report, seen from Windows-&gt;Devices and Simulators-&gt;View Device Logs, would look like this (truncated for ease of demonstration)</p>
<pre><code>Thread 0 Crashed:
0   libsystem_kernel.dylib          0x0000000183a012ec __pthread_kill + 8
1   libsystem_pthread.dylib         0x0000000183ba2288 pthread_kill$VARIANT$mp + 376
2   libsystem_c.dylib               0x000000018396fd0c abort + 140
3   libsystem_c.dylib               0x0000000183944000 basename_r + 0
4   icdab_planets                   0x00000001008e45bc 0x1008e0000 + 17852
5   UIKit                           0x000000018db56ee0
-[UIViewController loadViewIfRequired] + 1020

Binary Images:
0x1008e0000 - 0x1008ebfff icdab_planets arm64
  &lt;9ff56cfacd66354ea85ff5973137f011&gt;
   /var/containers/Bundle/Application/BEF249D9-1520-40F7-93F4-8B99D913A4AC/
   icdab_planets.app/icdab_planets</code></pre>
<p>However with the setting in place, a crash would instead be reported as:</p>
<pre><code>Thread 0 Crashed:
0   libsystem_kernel.dylib          0x0000000183a012ec __pthread_kill + 8
1   libsystem_pthread.dylib         0x0000000183ba2288
pthread_kill$VARIANT$mp + 376
2   libsystem_c.dylib               0x000000018396fd0c abort + 140
3   libsystem_c.dylib               0x0000000183944000 basename_r + 0
4   icdab_planets                   0x0000000104e145bc
-[PlanetViewController viewDidLoad] + 17852 (PlanetViewController.mm:33)
5   UIKit                           0x000000018db56ee0
-[UIViewController loadViewIfRequired] + 1020</code></pre>
<p>Lines 0, 1, 2, 5 are the same in both cases because our developer environment will have the symbols for the iOS release under test. In the second case Xcode will look up the DSYM file to clarify line 4. It tells us this is line 33 in file PlanetViewController.mm. This is:</p>
<pre><code>assert(pluto_volume != 0.0);</code></pre>
<h2 id="dsym-structure">DSYM structure</h2>
<p>The DSYM file is strictly speaking a directory hierarchy:</p>
<pre><code>icdab_planets.app.dSYM
icdab_planets.app.dSYM/Contents
icdab_planets.app.dSYM/Contents/Resources
icdab_planets.app.dSYM/Contents/Resources/DWARF
icdab_planets.app.dSYM/Contents/Resources/DWARF/icdab_planets
icdab_planets.app.dSYM/Contents/Info.plist</code></pre>
<p>It is just the DWARF data normally put into the debug binary but copied into a separate file.</p>
<p>From looking at your build log you can see how the DSYM was generated. It is effectively just <code>dsymutil path_to_app_binary -o output_symbols_dir.dSYM</code></p>
<h2 id="manual-symbolification">Manual Symbolification</h2>
<p>In order to help us get comfortable with crash dump reports, we can demonstrate how the symbolification actually works. In the first crash dump we want to understand:</p>
<pre><code>4   icdab_planets                   0x00000001008e45bc 0x1008e0000 + 17852</code></pre>
<p>If we knew accurately the version of our code at the time of the crash we can recompile our program but with the DSYM setting switched on and then get a DSYM file after the original crash. It should line up almost exactly.</p>
<p>The crash dump program tells us where the program was loaded in memory at the time of the problem. This is important because it is a master base offset from which all other address (TEXT) locations are relative to. At the bottom of the crash dump we have line <code>0x1008e0000 - 0x1008ebfff icdab_planets</code></p>
<p>So the icdab_planets binary starts at location <code>0x1008e0000</code></p>
<p>Running the lookup command <code>atos</code> symbolicates the line of interest:</p>
<pre><code># atos -arch arm64 -o ./icdab_planets.app.dSYM/Contents/Resources/DWARF/
icdab_planets -l 0x1008e0000 0x00000001008e45bc
-[PlanetViewController viewDidLoad] (in icdab_planets)
 (PlanetViewController.mm:33)</code></pre>
<p>The crash reporter tool fundamentally just uses <code>atos</code> to symbolicate the crash report, as well as providing other system related information.</p>
<p>Symbolification is described further by an Apple Technote in case you want to get into it in more detail. <span class="citation" data-cites="tn2123">(“CrashReport Technote 2123” n.d.)</span></p>
<h2 id="reverse-engineering-approach">Reverse Engineering Approach</h2>
<p>In the above example we have the source code and symbols for the crash dump so can do Symbolification.</p>
<p>Sometimes we may have included a third party binary framework in our project for which we do not have the source code. It is good practice for the vendor to supply symbol information for their framework to allow crash dump analysis. When symbol information is not available, it is still possible to make progress by applying some reverse engineering.</p>
<p>When working with third parties there is typically a much larger turnaround time for diagnostics and troubleshooting. We find that well written and specific bug reports can speed up things a lot. The following approach can help provide the kind of specific information needed.</p>
<p>We shall demonstrate our approach using the Hopper tool mentioned in the Tooling chapter.</p>
<p>Launching hopper, we choose File-&gt;Read Executable to Disassemble. The binary in our case is <code>examples/assert_crash_ios/icdab_planets</code></p>
<p>We need to “rebase” our disassembly so the addresses it shows mirror those of the program when it crashed. We choose Modify-&gt;Change File Base Address. As before, we supply <code>0x1008e0000</code>.</p>
<p>Now we can visit the code which crashed. The address <code>0x00000001008e45bc</code> is actually the address the device would <em>return</em> to after performing the function call in the stack trace. Nevertheless it puts us in the right part of the file. We choose Navigate-&gt;Go To Address or Symbol and supply <code>0x00000001008e45bc</code></p>
<p>The overall view we see is</p>
<p><img src="screenshots/hopperAddressView.png" /></p>
<p>Zooming in on the code line, we have</p>
<p><img src="screenshots/hopperPlanetAbort.png" /></p>
<p>This indeed shows the return address for the assert method. Further up we see the test for Pluto’s volume being non-zero. This is just a very basic Hopper example. We shall revisit Hopper later to demonstrate its most interesting feature - that of being able to generate pseudocode from assembly code. This lowers the mental load of comprehending crashes. Most developers rarely look at assembly code nowadays so this feature is worth the cost of the software itself!</p>
<p>Now at least for the current problem, we could formulate a bug report that said the code was crashing because Pluto’s volume was zero. That may be enough to unlock the problem from the framework vendor’s point of view.</p>
<p>In a more complex case, imagine we were using an image conversion library which was crashing. Since there can be many pixel formats for images, an assert might lead us to notice it was the format that was asserting and we could just try a different pixel format.</p>
<p>Another example would be a security library. Security code often gives back generic error codes, not specific fault codes to allow for future code enhancement and avoid leaking internal details. A crash dump in a security library might point out exactly the kind of security issue, and help us correct some data structure passed into the library much earlier on.</p>
<h1 id="a-siri-crash">A Siri Crash</h1>
<h2 id="why-are-we-looking-at-a-siri-crash">Why are we looking at a Siri Crash?</h2>
<p>Here is an example of Siri crashing on a Mac. Note that binaries on a Mac are not encrypted. This means we can demonstrate the use of third party tools to explore the binaries at fault. Since only Apple has the source code for Siri, it adds to the challenge and forces us think abstractly about the problem.</p>
<h2 id="the-crash-report">The Crash report</h2>
<p>Here is the crash report, suitably truncated for ease of demonstration:</p>
<pre><code>Process:               SiriNCService [1045]
Path:                  
/System/Library/CoreServices/Siri.app/Contents/XPCServices/SiriNCService.xpc/
Contents/MacOS/SiriNCService
Identifier:            com.apple.SiriNCService
Exception Type:        EXC_BAD_ACCESS (SIGSEGV)
Exception Codes:       KERN_INVALID_ADDRESS at 0x0000000000000018
Exception Note:        EXC_CORPSE_NOTIFY
VM Regions Near 0x18:
--&gt;
    __TEXT                 0000000100238000-0000000100247000
    [   60K] r-x/rwx SM=COW  /System/Library/CoreServices/Siri.app/Contents/
    XPCServices/SiriNCService.xpc/Contents/MacOS/SiriNCService

Application Specific Information:
objc_msgSend() selector name: didUnlockScreen:

Thread 0 Crashed:: Dispatch queue: com.apple.main-thread
0   libobjc.A.dylib                 0x00007fff69feae9d objc_msgSend + 29
1   com.apple.CoreFoundation        0x00007fff42e19f2c
 __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 12
2   com.apple.CoreFoundation        0x00007fff42e19eaf
___CFXRegistrationPost_block_invoke + 63
3   com.apple.CoreFoundation        0x00007fff42e228cc
 __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
4   com.apple.CoreFoundation        0x00007fff42e052a3 __CFRunLoopDoBlocks + 275
5   com.apple.CoreFoundation        0x00007fff42e0492e __CFRunLoopRun + 1278
6   com.apple.CoreFoundation        0x00007fff42e041a3
CFRunLoopRunSpecific + 483
7   com.apple.HIToolbox             0x00007fff420ead96
RunCurrentEventLoopInMode + 286
8   com.apple.HIToolbox             0x00007fff420eab06
ReceiveNextEventCommon + 613
9   com.apple.HIToolbox             0x00007fff420ea884
_BlockUntilNextEventMatchingListInModeWithFilter + 64
10  com.apple.AppKit                0x00007fff4039ca73 _DPSNextEvent + 2085
11  com.apple.AppKit                0x00007fff40b32e34
-[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 3044
12  com.apple.ViewBridge            0x00007fff67859df0
-[NSViewServiceApplication nextEventMatchingMask:untilDate:inMode:dequeue:] + 92
13  com.apple.AppKit                0x00007fff40391885 -[NSApplication run] + 764
14  com.apple.AppKit                0x00007fff40360a72 NSApplicationMain + 804
15  libxpc.dylib                    0x00007fff6af6cdc7 _xpc_objc_main + 580
16  libxpc.dylib                    0x00007fff6af6ba1a xpc_main + 433
17  com.apple.ViewBridge            0x00007fff67859c15
-[NSXPCSharedListener resume] + 16
18  com.apple.ViewBridge            0x00007fff67857abe
NSViewServiceApplicationMain + 2903
19  com.apple.SiriNCService         0x00000001002396e0 main + 180
20  libdyld.dylib                   0x00007fff6ac12015 start + 1</code></pre>
<h2 id="the-crash-details">The Crash details</h2>
<p>Looking at the 09:52 crash we see</p>
<p><code>Exception Type:        EXC_BAD_ACCESS (SIGSEGV)</code></p>
<p>This means we are accessing memory which does not exist. The program that was running (known as the TEXT) was</p>
<pre><code>/System/Library/CoreServices/Siri.app/Contents/XPCServices/SiriNCService.xpc/
Contents/MacOS/SiriNCService</code></pre>
<p>This is interesting because normally its applications that crash. Here we see a software component crashing. The Siri service is a distributed app which uses cross process communication (xpc) to do its work. We see that from references to xpc as above.</p>
<p>What method were we trying to call on an object that no longer exists? Helpfully, the crash dump provides the answer:</p>
<p><code>Application Specific Information: objc_msgSend() selector name: didUnlockScreen:</code></p>
<p>Now we have to a first level approximation answered the <em>what</em>, <em>where</em> and <em>when</em> aspect of the crash. It was a Siri component that crashed, in <code>SiriNCService</code> when <code>didUnlockScreen</code> was called on a non-existent object.</p>
<h2 id="applying-our-tool-box">Applying our Tool Box</h2>
<p>Now to understand further we need to reach for the <code>class-dump</code> tool.</p>
<p><code>class-dump SiriNCService &gt; SiriNCService.classdump.txt</code></p>
<p>Looking at a portion of the output is the following:</p>
<pre><code>@property __weak SiriNCService *service; // @synthesize service=_service;
- (void).cxx_destruct;
- (BOOL)isSiriListening;
- (void)_didUnlockScreen:(id)arg1;
- (void)_didLockScreen:(id)arg1;</code></pre>
<p>We see that there is indeed a method, <code>didUnlockScreen</code>, and we see that there is a service object which is owned <strong>weakly</strong>. This means that the object is not retained and could get freed. It typically means we a user of the <code>SiriNCService</code> but not the owner. We do not own the lifecycle of the object.</p>
<h2 id="software-engineering-insights">Software Engineering Insights</h2>
<p>The underlying software engineering problem here is one of lifecycle. Part of the application has a object lifecycle we were not expecting. The consumer should have been written to detect the absence of the service as a robustness and defensive programming best practice. What can happen is that the software is maintained over time, and the lifecycles of objects grow more complex over time as new functionality is added but the old code using the objects is not updated in sync.</p>
<p>Taking one step further back we should ask what weak properties are used by this component? From that we can create some simple unit test cases which test the code whilst those objects are nil. Then we can go back and add robustness to the code paths that assumed the object were non-nil.</p>
<p>Taking a further step back, is there anything unusual in the design of this component that calls for integration testing?</p>
<pre><code>grep -i heat SiriNCService.classdump.txt
@protocol SiriUXHeaterDelegate &lt;NSObject&gt;
- (void)heaterSuggestsPreheating:(SiriUXHeater *)arg1;
- (void)heaterSuggestsDefrosting:(SiriUXHeater *)arg1;
@interface SiriNCAlertViewController : NSViewController
&lt;SiriUXHeaterDelegate, AFUISiriViewControllerDataSource,
 AFUISiriViewControllerDelegate&gt;
    SiriUXHeater *_heater;
@property(readonly, nonatomic)
SiriUXHeater *heater; // @synthesize heater=_heater;
- (void)heaterSuggestsPreheating:(id)arg1;
- (void)heaterSuggestsDefrosting:(id)arg1;
@interface SiriUXHeater : NSObject
    id &lt;SiriUXHeaterDelegate&gt; _delegate;
@property(nonatomic)
__weak id &lt;SiriUXHeaterDelegate&gt; delegate; // @synthesize delegate=_delegate;
- (void)_suggestPreheat;</code></pre>
<p>It seems that this component can be prepared and made ready and has a variety of levels of initialisation and de-initialisation. Maybe this complexity is to make the user interface responsive. But it sends us a message that this component needs an integration test suite that codifies the state machine so we know the lifecycle of the service.</p>
<h2 id="lessons-learnt-2">Lessons Learnt</h2>
<p>We went from using HOWTO knowledge (understanding the crash report) to using tooling to get a baseline level of knowledge. Then we started to apply Software Engineering experiences, and then we started reasoning about the actual design of the component to ask how we got here and what should be done to avoid the problem. This journey from looking at the artefacts of a problem to getting to the root of what needs to be done is a common theme during crash dump analysis. It cannot be achieved by just focusing on the HOWTO of comprehending crash reports. We need to switch hats and see things from different perspectives in order to really make progress.</p>
<h1 id="bibliography" class="unnumbered">Bibliography</h1>
<div id="refs" class="references">
<div id="ref-tn2123">
<p>“CrashReport Technote 2123.” n.d. Accessed 2004.</p>
</div>
<div id="ref-icdabgithub">
<p>“IOS Crash Dump Analysis Book Github Resources.” 2018. <a href="https://github.com/faisalmemon/ios-crash-dump-analysis-book" class="uri">https://github.com/faisalmemon/ios-crash-dump-analysis-book</a>.</p>
</div>
<div id="ref-class-dump-tool">
<p>Nygard, Steve. 2018. “Class Dump Tool.” <a href="http://stevenygard.com/projects/class-dump/" class="uri">http://stevenygard.com/projects/class-dump/</a>.</p>
</div>
</div>
</body>
</html>
