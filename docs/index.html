<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="By Faisal Memon" />
  <title>iOS Crash Dump Analysis</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="style/gitHubStyle.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<header>
<h1 class="title">iOS Crash Dump Analysis</h1>
<p class="author">By Faisal Memon</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#quick-start">Quick Start</a><ul>
<li><a href="#troubleshooting">Troubleshooting</a><ul>
<li><a href="#missing-resource-issue">Missing resource issue</a></li>
<li><a href="#binary-compatibility-issue">Binary compatibility issue</a></li>
<li><a href="#simulator-only-issue">Simulator only issue</a></li>
<li><a href="#site-specific-issues">Site specific issues</a></li>
<li><a href="#customer-device-deployment-issues">Customer device deployment issues</a></li>
<li><a href="#locale-specific-issues">Locale specific issues</a></li>
</ul></li>
<li><a href="#the-crash-mindset">The Crash Mindset</a><ul>
<li><a href="#locale-based-crash">Locale based Crash</a></li>
<li><a href="#geographic-location-crash">Geographic Location Crash</a></li>
<li><a href="#bus-noise-crash">Bus Noise Crash</a></li>
</ul></li>
</ul></li>
<li><a href="#basic-concepts">Basic Concepts</a><ul>
<li><a href="#what-is-a-crash">What is a crash?</a></li>
<li><a href="#operating-environment-policies">Operating Environment Policies</a><ul>
<li><a href="#nil-handling-example">Nil Handling Example</a></li>
<li><a href="#mac-address-example">MAC Address Example</a></li>
<li><a href="#camera-example">Camera Example</a></li>
<li><a href="#lessons-learnt">Lessons Learnt</a></li>
</ul></li>
<li><a href="#application-policies">Application policies</a><ul>
<li><a href="#when-should-we-crash">When should we crash?</a></li>
<li><a href="#when-should-we-not-crash">When should we not crash?</a></li>
</ul></li>
<li><a href="#engineering-guidance">Engineering Guidance</a><ul>
<li><a href="#unit-testing-the-mac-address">Unit Testing the MAC Address</a></li>
<li><a href="#ui-testing-camera-access">UI Testing Camera access</a></li>
</ul></li>
</ul></li>
<li><a href="#tooling">Tooling</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#reverse-engineering">Reverse Engineering</a></li>
<li><a href="#class-dump-tool">Class Dump Tool</a></li>
</ul></li>
<li><a href="#xcode-built-in-help">Xcode Built-In Help</a><ul>
<li><a href="#xcode-diagnostic-settings">Xcode Diagnostic Settings</a><ul>
<li><a href="#execution-methodology">Execution Methodology</a></li>
<li><a href="#analysis-methodology">Analysis Methodology</a></li>
<li><a href="#process-methodology">Process Methodology</a></li>
</ul></li>
<li><a href="#the-middle-road">The Middle Road</a></li>
</ul></li>
<li><a href="#hybrid-environments">Hybrid Environments</a><ul>
<li><a href="#program-structure">Program structure</a></li>
<li><a href="#paradigms">Paradigms</a></li>
<li><a href="#the-problem">The Problem</a></li>
<li><a href="#solutions">Solutions</a><ul>
<li><a href="#stl-solution">STL Solution</a></li>
<li><a href="#facade-solution">Facade Solution</a></li>
</ul></li>
<li><a href="#lessons-learnt-1">Lessons Learnt</a></li>
</ul></li>
<li><a href="#symbolification">Symbolification</a><ul>
<li><a href="#build-process">Build Process</a></li>
<li><a href="#build-settings">Build Settings</a></li>
<li><a href="#observing-a-local-crash">Observing a local crash</a></li>
<li><a href="#dsym-structure">DSYM structure</a></li>
<li><a href="#manual-symbolification">Manual Symbolification</a></li>
<li><a href="#reverse-engineering-approach">Reverse Engineering Approach</a></li>
</ul></li>
<li><a href="#the-crash-report">The Crash Report</a><ul>
<li><a href="#system-diagnostics">System Diagnostics</a><ul>
<li><a href="#extracting-system-diagnostic-information">Extracting System Diagnostic Information</a></li>
</ul></li>
<li><a href="#guided-tour-of-an-ios-crash-report">Guided tour of an iOS Crash Report</a><ul>
<li><a href="#crash-report-header-section">Crash Report Header Section</a></li>
<li><a href="#crash-report-date-and-version-section">Crash Report Date and Version Section</a></li>
<li><a href="#crash-report-exception-section">Crash Report Exception Section</a></li>
<li><a href="#crash-report-filtered-syslog-section">Crash Report Filtered Syslog Section</a></li>
<li><a href="#crash-report-thread-section">Crash Report Thread Section</a></li>
</ul></li>
</ul></li>
<li><a href="#a-siri-crash">A Siri Crash</a><ul>
<li><a href="#why-are-we-looking-at-a-siri-crash">Why are we looking at a Siri Crash?</a></li>
<li><a href="#the-crash-report-1">The Crash report</a></li>
<li><a href="#the-crash-details">The Crash details</a></li>
<li><a href="#applying-our-tool-box">Applying our Tool Box</a></li>
<li><a href="#software-engineering-insights">Software Engineering Insights</a></li>
<li><a href="#lessons-learnt-2">Lessons Learnt</a></li>
</ul></li>
<li><a href="#bibliography">Bibliography</a></li>
</ul>
</nav>
<h1 id="preface">Preface</h1>
<p>This book grew from an inspiration gained back in the late 1990s.</p>
<p>It’s hard to overstate the euphoria of the moment. The Internet was the next Industrial Revolution. Investors saw it as the best place to put their money. Hardware, software and services were all experiencing a Cambrian explosion of diversity and innovation.</p>
<p>I found myself at the center of things. I was newly recruited to Sun Microsystems. At that time, if you had a great idea for a website and wanted to start serving your customers, Sun Microsystems computers were an essential purchase. These were servers that you would either house yourself or place with a co-location provider.</p>
<p>Computer technology was already well developed by then, but existing solutions were now being put to use in new scenarios, and at Internet-scale. What was a perfectly good implementation of Unix, SunOS, from the rarefied halls of Stanford University was now running on E-Bay and had to be up and running without a glitch.</p>
<p>We had an electronic board showing the status of our critical customers. Saudi Aramco was permanently lit in red to such an extent that we wondered if that was a fault on the board itself.</p>
<p>My first day was somewhat ignominious. I wasn’t even given my own cubicle. My desk looked like a school table. My keyboard had several faulty and inoperative keys. I sat in one corner of a vast cube-farm and actually forgot which corner it was at on the first day. After lunch, I returned to my desk after an extensive walk around the other corners.</p>
<p>One thing struck me was that there was a book sitting on the desk of about a quarter of the 500 odd engineers. It proudly said on the front cover, “Panic!” <span class="citation" data-cites="panicbook">(<em>Panic! Unix System Crash Dump Analysis</em> 1995)</span>. It was a book on SunOS crash dump analysis.</p>
<p>After acquiring a proper cubicle and getting to know my colleagues, I noticed that the engineers with the “Panic!” book just seemed to have that extract edge in low-level issues reported by Customers. Collectively it lifted the problem solving IQ of the Answer Center where I worked.</p>
<p>At Sun, there was a deep culture of learning. We were given such extensive training and support it was often the case we’d be doing seven courses per year, each a week long.</p>
<p>All was good until one course came up. It was called Analytical Troubleshooting (ATS). This caused great controversy within the Answer Center. It was a formal methodology for solving problems. It could not tell you the answers, but it would ensure you were forced to ask the right questions. It turned out that on our hardest problems, we were missing asking the right questions.</p>
<p>This was a major step forwards again in productivity. Nevertheless, some engineers, quite out of character, were loudly critical. It turned out that these techniques were just things experienced engineers had learnt as part of their craft and they didn’t want the magic to be laid bare for anyone to pick up cheaply.</p>
<p>One day Chris Drake was in town and popped into our office. He was the x86 architecture specialist that collaborated with Kimberley Brown to produce the “Panic!” book. They arranged a workshop to educate us on SunOS crashes on x86 architecture. It was something of a novelty at the time, prior to the remarkable rise of Linux and the GNU/Linux system.</p>
<p>I remember one time, as an undergraduate student during an Operating Systems lecture, I looked across the room. I noticed it was full of Sun Microsystems equipment; I stared into the Sun logo and dreamed of one day working there. It came true. So in my workshop on x86 panics, I had another idea. One day I would write a book. It would be something quite focussed on a single technical problem. It would be something that would convey the experiences I had obtained in my career. It turns out that came true as well in the book you are reading now!</p>
<h1 id="introduction">Introduction</h1>
<p>This book fills a gap that has emerged between Application Developers and the platform they are developing for when a crash occurs. The mindset of the Application developer is largely understanding high-level concepts and abstractions. When a crash occurs, you can often feel rudely transported into a command line UNIX world of low level constructs, pointers and raw data.</p>
<p>We focus exclusively on the Apple ecosystem.</p>
<p>We cover macOS, tvOS, watchOS platforms, ARM Assembly, and C (CoreFoundation), Objective-C, and Objective-C++ and Swift programming languages. This is because the older languages are more prone to crash bugs. Real world applications tend to end up being a hybrid between the safer Swift language and older technologies.</p>
<p>We assume you have at least an introductory knowledge of iOS programming and software engineering, and have access to a Mac with Xcode.</p>
<p>The approach we take is to combine three different perspectives on the problem to give a rounded and robust view of the situation and how to resolve it.</p>
<p>Our three perspectives are:</p>
<ol type="1">
<li>A practical HOW-TO guide for using the excellent tooling available from Apple.</li>
<li>A discussion of software engineering concepts tailored to preventing and resolving crashes.</li>
<li>A formal problem-solving approach but applied to crash analysis.</li>
</ol>
<p>Programming literature comprehensively has documented software engineering concepts, and Apple has documented their crash dump tooling via Guides and WWDC videos.</p>
<p>Formal problem solving is less discussed in software engineering circles, perhaps because it’s considered a table stakes skill for an engineer. It is however a discipline of its own and when directly studied can only enhance the “natural” abilities that seem to mark out the “technically-minded” folks from the rest of the population.</p>
<p>Our goal is not the shy away from repeating knowledge we’ve probably seen or read elsewhere but instead we take the viewpoint of explaining the whole narrative in a cohesive manner. What makes crash dump analysis hard is that significant background knowledge is often assumed in order to make room to concentrate on the particulars of a specific tool or crash report. That causes a barrier to entry, which this book aims to overcome.</p>
<p>To complement the book, there is a website of resources which is intended to be used alongside the printed material so example projects can be setup and run by yourself and experimented with. All references in this book are collected into the Bibliography Chapter at the end of the book. There you will find URLs to resources for example.</p>
<p>The GitHub website supporting the book at <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>

<h1 id="quick-start">Quick Start</h1>
<p>When an application crash appears after a recent code change, it can be straightforward to reason about the crash and look at the relevant code changes. Often, crashes just appear due to a change in operating environment. Those can be the most annoying. For example, the app runs fine in the Office but crashes at the customer Site. We don’t have time to get into why, but need a quick fix or workaround. Another common problem scenario arises when a new project is being explored. This is where we have no prior experience with the code base but immediately face crash problems after compilation and running the app.</p>
<p>In this chapter, we explore possible reasons for crashing due to a change in operating environment. Many problems can be dealt with without getting into logical analysis of the specifics of the problem at hand. In reality sometimes we just need to make progress, whilst making a note to go back and address the root cause.</p>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="missing-resource-issue">Missing resource issue</h3>
<p>Sometimes our app crashes on startup due to a missing resource issue.</p>
<p>We should try compiling and running other Xcode targets within the same project. Sometimes a specific target is the one that sets up the needed environment as part of the build. If so, we can make a note to address that later.</p>
<h3 id="binary-compatibility-issue">Binary compatibility issue</h3>
<p>Sometimes our app crashes on startup due to a binary compatibility issue.</p>
<p>If we’ve recently updated Xcode, or pulled code updates on top of a compiled project, we can perform an Option-Command-Shift-K clean which cleans the build area of intermediates, and then re-build as normal.</p>
<h3 id="simulator-only-issue">Simulator only issue</h3>
<p>Sometimes our app crashes only on simulator.</p>
<p>Here we should try Simulator Hardware-&gt;Reset all content and settings. We can try iPad simulator instead of iPhone simulator or vice-versa. Sample projects are often used to explain a particular technology without regard to productisation or generality.</p>
<h3 id="site-specific-issues">Site specific issues</h3>
<p>Sometimes our app only crashes when at customer site.</p>
<p>We can check Wi-Fi settings or try hot-spotting our iPad to an iPhone. Sometimes network issues such as connectivity, or latency are overlooked when developing our app in the office/home environment. We should make a note to fix networking assumptions if that is the problem.</p>
<h3 id="customer-device-deployment-issues">Customer device deployment issues</h3>
<p>Sometimes our app only crashes when deploying on a customer device gives problems.</p>
<p>If we cable up our laptop to the customer’s device, we’re probably doing a Debug release deployment. This means push notification tokens will be the development tokens not the production tokens. It also may mean that resource access grants (to Camera for example) are no longer valid as they may have been approved via a TestFlight or App Store version of the app previously (production version).</p>
<p>We should try switching deployment configuration via Command-&lt; selecting Run in the left panel, Info tab in the right panel, Build Configuration setting Release (not Debug). We should also manually check any resource access grants in the iPad/iPhone settings.</p>
<h3 id="locale-specific-issues">Locale specific issues</h3>
<p>Sometimes deploying with the customer’s locale causes a crash.</p>
<p>Resource files might be absent in the wrong locale. Furthermore, locale handling is rife with undocumented special cases. We should try changing the locale temporarily to a known working one. Make a note to return to the issue when back in the office.</p>
<h2 id="the-crash-mindset">The Crash Mindset</h2>
<p>One take away lesson from the above examples is that we need to think of our code in a wider context. We should think of the operating environment of our app. This comprises:</p>
<ul>
<li>the compiled code</li>
<li>binary incompatibilities between code modules (different language versions, compilers and toolchains)</li>
<li>resource files bundled or downloaded into the app</li>
<li>the build configuration (e.g. Release or Debug)</li>
<li>the network environment, availability/latency/speed</li>
<li>permissions granted to the app</li>
<li>permissions denied to the app (in a Mobile Device Management secured environment)</li>
<li>platform variants</li>
<li>orientation</li>
<li>foreground and background operating modes</li>
<li>hardware performance (old slow hardware versus faster newer devices)</li>
<li>hardware components (GPU, Memory, CPU, accessories, etc.)</li>
<li>geographic location related issues</li>
<li>locale issues</li>
<li>presence of diagnostics settings</li>
<li>presence of a debugger or profiler</li>
<li>the OS version of the target device</li>
</ul>
<p>As a first step in getting into the correct mindset to tackle app crashes, its worthwhile working through each of the above operating environment differences and trying to note down if such a difference ever resulted in a crash that we know about or suspect could happen. This teaches us that crashes are much more about <strong>environment</strong> than about <strong>source code</strong>. Another secondary insight is that the more able we are to produce a list of hypotheses given a specific environment difference, the more easily and quickly we will be able to find the root cause of crashes that seem mysterious to other people, and almost magical that we came up with a suggestion of where the problem could be.</p>
<p>Here are some curious examples of crashes from the Information Technology folklore to whet our appetite and get us thinking:</p>
<h3 id="locale-based-crash">Locale based Crash</h3>
<p>The Russian locale caused a crash during date processing.</p>
<p>This was because 1984-04-01 was being used as a sentinel date marker. However, in Russia, there is no such date/time because there is no midnight at that point in time. Daylight time started in Russia on that date with a +1 hour.</p>
<p>This was seen during development of the WecudosPro iPad app when it was tested in Russia</p>
<h3 id="geographic-location-crash">Geographic Location Crash</h3>
<p>A computer was crashing each day at a different time.</p>
<p>The actual problem was the computer was near a window next to an estuary where ships passed by. At high tide, a military ship would sail past and its RADAR would disrupt the electronics and cause a crash.</p>
<p>This folklore story was told to Sun Microsystems Answer Center engineers in the UK during Kepner-Tregoe formal problem solving training.</p>
<h3 id="bus-noise-crash">Bus Noise Crash</h3>
<p>When a computer was under both heavy network load and disk load the system would</p>
<p>The crash was due corruption on disk. There were zeroes very 64 bytes. It was the cache line size of the computer. The memory board was not wired up correctly causing noise at 64 byte boundaries picked up by the disk ribbon cable sitting next to it.</p>
<p>This was seen during the development of Sun Volume Systems Group prototype hardware build.</p>
<h1 id="basic-concepts">Basic Concepts</h1>
<h2 id="what-is-a-crash">What is a crash?</h2>
<p>An application crash is something the Operating Environment does to our application in response to what we have done (or failed to do) in the Operating Environment that violates some <em>policy</em> of the platform we are running on.</p>
<h2 id="operating-environment-policies">Operating Environment Policies</h2>
<p>The policies of the operating environment are there to ensure security, data safety, performance, and privacy of the environment to the user.</p>
<h3 id="nil-handling-example">Nil Handling Example</h3>
<p>Newcomers to the Apple ecosystem are often surprised to learn that Objective-C allows us to message a nil object. It silently ignores the failed dispatch. For example, the following method runs ok.</p>
<pre><code>- (void)nilDispatchDoesNothing
{
    NSString *error = NULL;
    assert([error length] == 0);
}</code></pre>
<p>The Objective-C runtime authors made a judgement call, and decided it was better for an application to ignore such problems.</p>
<p>However if we deference a C pointer we get a crash.</p>
<pre><code>void nullDereferenceCrash() {
    char *nullPointer = NULL;
    assert(strlen(nullPointer) == 0);
}</code></pre>
<p>The authors of the operating system have setup the system so access to this and other low memory addresses causes the hardware to trap on this illegal access and abort our program.</p>
<p>This area of memory is set aside by the operating system because it indicates a programming error of not setting up an object or data structure properly.</p>
<p>When things go wrong, we don’t always get a crash. Only if it is Operating Environment policy then we get a crash.</p>
<h3 id="mac-address-example">MAC Address Example</h3>
<p>Consider the example of getting the MAC address of our iPhone. The Media Access Control (MAC) address is a unique code allocated to network cards to allow machines to talk to each other without duplication at the Data Link layer of the communication stack.</p>
<p>Prior to iOS 7, the MAC address was not considered a sensitive API. So requesting the MAC address using the <code>sysctl</code> API gave the real address. To see this in action, see the <code>icdab_sample</code> app <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span>.</p>
<p>Unfortunately, the API was abused as a way of tracking the user - a privacy violation. Therefore, Apple introduced a policy from iOS 7 where they would return a fixed MAC address always.</p>
<p>Apple could have chosen to crash our app when any call to <code>sysctl</code> was made. However, <code>sysctl</code> is a general-purpose low-level call which can be used for other valid purposes. Therefore the policy set by iOS was to return a fixed MAC address <code>02:00:00:00:00:00</code> whenever that was requested.</p>
<h3 id="camera-example">Camera Example</h3>
<p>Now lets consider the case of taking a photo using the camera.</p>
<p>Introduced in iOS 10, when we want to access the Camera, a privacy sensitive feature, we need to define human readable text that is presented inside the system permission dialogue before access to the Camera is granted.</p>
<p>If we don’t define the text in our <code>Info.plist</code> for <code>NSCameraUsageDescription</code> we still see the following code evaluating true and then attempting to present the image picker.</p>
<pre><code>if UIImagePickerController.isSourceTypeAvailable(
      UIImagePickerControllerSourceType.camera) {
      let imagePicker = UIImagePickerController()
      imagePicker.delegate = self
      imagePicker.sourceType = UIImagePickerControllerSourceType.camera
      imagePicker.allowsEditing = false
      self.present(imagePicker, animated: true, completion: nil)
      }</code></pre>
<p>However when we run the code we see a crash with a descriptive console message:</p>
<pre><code>2018-07-10 20:09:21.549897+0100 icdab_sample[1775:15601294]
 [access] This app has crashed because it attempted to access
  privacy-sensitive data without a usage description.  
  The app&#39;s Info.plist must contain an NSCameraUsageDescription
   key with a string value explaining to the user how the app
   uses this data.
Message from debugger: Terminated due to signal 9</code></pre>
<h3 id="lessons-learnt">Lessons Learnt</h3>
<p>Note the contrast here. In both cases there was a privacy sensitive API. However, in the camera case, Apple chose a policy of crashing our app instead of giving a warning, allowing a boilerplate standard explanation dialog, or returning a <code>false</code> value to indicate the source type was not available.</p>
<p>This underlies the point about there being two entities involved, the program and the operating environment (which includes its policies). Having correct source code does not guarantee crash free running. When we see a crash we need to think about the operating environment as much as the code itself.</p>
<h2 id="application-policies">Application policies</h2>
<p>The application we are writing can also request a crash. This is typically done via <code>assert</code> calls in our code. These calls ask the Operating Environment to terminate our app if any <code>assert</code> has failed. The Operating Environment then aborts our app. In the crash report we get a:</p>
<p><code>Exception Type:  EXC_CRASH (SIGABRT)</code></p>
<p>to indicate it was the application that requested the crash in the first place.</p>
<h3 id="when-should-we-crash">When should we crash?</h3>
<p>We can apply similar standards as the Operating Environment for our crash policy.</p>
<p>If our code detects a data integrity issue, we could crash to prevent further data corruption.</p>
<h3 id="when-should-we-not-crash">When should we not crash?</h3>
<p>If the problems have resulted directly from some IO problem (file or network access for example) or some human input problem (such as a bad date value) then we should not crash.</p>
<p>It’s our job as the application developer to shield the lower level parts of the system from unpredictability present in the real world. Such problems are better dealt with by logging, error handling, user alerts, and IO retries.</p>
<h2 id="engineering-guidance">Engineering Guidance</h2>
<p>How should we guard against the privacy problems described above?</p>
<p>The thing to keep in mind is that any code that touches upon the policies the Operating Environment has guards for is a good candidate for automated testing.</p>
<p>In the <code>icdab_sample</code> project we have created Unit tests and UI tests.</p>
<p>Test cases always feel over-the-top when applied to trivial programs. But consider a large program that has an extensive <code>Info.plist</code> file. A new version of the app is called for so another <code>Info.plist</code> is created. Then keeping the privilege settings in sync between the different build targets becomes an issue. The UI test code shown here which merely launches the camera can catch such problems easily so has practical business value.</p>
<p>Similarly, if our app has a lot of low-level code and then is ported from iOS to tvOS for example, how much of that OS-sensitive code is still applicable?</p>
<p>Unit testing a top level function comprehensively for different design concerns can pay off the effort invested in it before delving deeper and unit testing the underlying helper function calls in our code base. It’s a strategic play allowing us to get some confidence in our application and early feedback on problem areas when porting to other platforms within the Apple Ecosystem (and beyond).</p>
<h3 id="unit-testing-the-mac-address">Unit Testing the MAC Address</h3>
<p>The code to get the MAC address is not trivial. Therefore it merits some level of testing.</p>
<p>Here is a snippet from the Unit tests:</p>
<pre><code>    func getFirstOctectAsInt(_ macAddress: String) -&gt; Int {
        let firstOctect = macAddress.split(separator: &quot;:&quot;).first!
        let firstOctectAsNumber = Int(String(firstOctect))!
        return firstOctectAsNumber
    }

    func testMacAddressNotNil() {
        let macAddress = MacAddress().getMacAddress()
        XCTAssertNotNil(macAddress)
    }

    func testMacAddressIsNotRandom() {
        let macAddressFirst = MacAddress().getMacAddress()
        let macAddressSecond = MacAddress().getMacAddress()
        XCTAssert(macAddressFirst == macAddressSecond)
    }

    func testMacAddressIsUnicast() {
        let macAddress = MacAddress().getMacAddress()!
        let firstOctect = getFirstOctectAsInt(macAddress)
        XCTAssert(0 == (firstOctect &amp; 1))
    }

    func testMacAddressIsGloballyUnique() {
        let macAddress = MacAddress().getMacAddress()!
        let firstOctect = getFirstOctectAsInt(macAddress)
        XCTAssert(0 == (firstOctect &amp; 2))
    }</code></pre>
<p>In fact, the last test fails because the OS returns a local address.</p>
<h3 id="ui-testing-camera-access">UI Testing Camera access</h3>
<p>For testing camera access, we have written a simple UI test case which just presses the Take Photo button (by means of an accessibility identifier <code>takePhotoButton</code>)</p>
<pre><code>func testTakePhoto() {
    let app = XCUIApplication()
    app.buttons[&quot;takePhotoButton&quot;].tap()
}</code></pre>
<p>This UI test code caused an immediate crash.</p>
<h1 id="tooling">Tooling</h1>
<h2 id="overview">Overview</h2>
<p>We have a rich set of tools available to assist crash dump analysis. When used properly they can save a huge amount of time.</p>
<p>Xcode provides much help out of the box. However, using and comprehending the information Xcode tools provide is daunting. In later chapters, we go through examples showing the use of such tools.</p>
<p>Additionally there are command line tools provided as standard in macOS. These are helpful when used in particular usage scenarios when we already know what we want to find out. We shall go through specific scenarios and show how the tools are used.</p>
<p>Next come software tools that help us reverse engineer programs. Sometimes we cannot get our program to work with a third party library. Aside from looking at Documentation or raising a Support Request, it’s possible to do some investigation ourselves using these tools.</p>
<h2 id="reverse-engineering">Reverse Engineering</h2>
<p>Reverse engineering is where an already built binary (such as an application, library, or helper process daemon), is studied to determine how it works. Normally, source code not binary code is studied to determine how a program works. For example:</p>
<ul>
<li>what are the lifecycles of the objects it is provided?</li>
<li>what checks does it do on objects?</li>
<li>what files or resources does it depend on?</li>
<li>why did it return a failure code?</li>
</ul>
<p>We generally do not want to know everything, only something specific to help build a hypothesis. Once we have a hypothesis, we will test it in relation to the crash dump are dealing with.</p>
<p>How far should we go with reverse engineering, and how much money and time to invest in it is a good question. We offer the following recommendation.</p>
<ul>
<li>If we are just starting our application developer journey, or we have limited funds, then just stick with the standard Xcode tooling, macOS command line, and the open source class-dump tool.</li>
<li>If we are a professional application developer, we should strongly consider buying a commercial reverse engineering tool. The one that draws most attention is Hopper; it provides a lot of functionality offered by IDA Pro (a high end tool). It is well priced and can pay for itself in gained productivity even if only used a handful of times. We show how Hopper can be used in this book.</li>
<li>If we are a professional penetration tester, reverse engineer, or security researcher, then we will be probably wanting to invest in the top of the line software tool, IDA Pro. The tool costs thousands but is often purchased as a company wide expense.</li>
</ul>
<h2 id="class-dump-tool">Class Dump Tool</h2>
<p>One of the great things about the Objective-C runtime is that it carries lots of rich program structure information in its built binaries. These allow the dynamic aspects of the language to work. In fact, its flexibility of dynamic dispatch is a source for many crashes.</p>
<p>We recommend installing the <code>class-dump</code> tool right away because we shall reference its usage in later chapters. See <span class="citation" data-cites="class-dump-tool">Nygard (2018)</span></p>
<p>The class dump tool allows us to look at what Objective C classes, methods and properties are present in a given program.</p>
<h1 id="xcode-built-in-help">Xcode Built-In Help</h1>
<p>Xcode provides a lot of help to developers in understanding and preventing crashes.</p>
<p>We think of Xcode in layers of sophistication, where at the lowest layer of sophistication Xcode directly tells us the common error it has seen with suggested corrections, up to the highest level were Xcode is telling the raw information, but we need Operating Systems knowledge to interpret the information ourselves.</p>
<p>We shall revisit Xcode configuration, setup and tooling many times. Nevertheless, let us first start off with the simple but high value assistance Xcode provides.</p>
<h2 id="xcode-diagnostic-settings">Xcode Diagnostic Settings</h2>
<p>By opening the project <code>icdab_sample</code> <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span> and looking at the Schema definition and then highlighting the Diagnostics tab we see the following options:</p>
<p><img src="screenshots/diagnostic_settings.png" /></p>
<h3 id="execution-methodology">Execution Methodology</h3>
<p>If we have a crash that is reproducible from our own developer environment and source code, then a methodology for finding is to switch on the appropriate diagnostic setting and then re-run our application.</p>
<p>As we become familiar with each diagnostic, we will know which option to switch on. We shall work through different scenarios so we understand when to use each. But when we are just starting out its worth just going through each one-by-one to get a feel for what is available. The basic approach is:</p>
<ol type="1">
<li>Write a Unit Test Case or UI Test Case that hits the problem.</li>
<li>Enable just one of the Diagnostic options from above starting with our best guess.</li>
<li>Run our tests.</li>
<li>Take note of any warning or console message from Xcode.</li>
<li>Repeat again but choosing a different diagnostic option if the problem is not understood.</li>
</ol>
<h3 id="analysis-methodology">Analysis Methodology</h3>
<p>Another complementary approach for analyzing and proactively avoiding crashes is to run the Code Analyzer. This is invoked using Command-Shift-B</p>
<p>In the sample app <code>icdab_sample</code> the Analyzer reports:</p>
<pre><code>/Users/faisalm/dev/icdab/source/icdab_sample/icdab_sample/macAddress.m:22:12:
 warning: Null pointer argument in call to string length function
    assert(strlen(nullPointer) == 0);</code></pre>
<p>and conveniently marks up our source code</p>
<p><img src="screenshots/analyser_null.png" /></p>
<p>This can be switched on for whenever the project is built, either in shallow or deep mode according to how we feel the tradeoff should be done between slower more thorough analysis versus quicker build times with less analysis. It is in the Build Settings tab for the Xcode project file.</p>
<p><img src="screenshots/static_analyser_build.png" /></p>
<p>For a large project that has never had an Analysis report done, the output can be overwhelming. There will be some noise in the report but it generally does a good job. There will be duplication in the report because certain classes of error will repeat throughout the code.</p>
<p>If we are developing code using the Agile software methodology, then it is possible to frame the report as potential backlog items that can be worked upon during the time allocated for refactoring and maintenance.</p>
<p>In a large software project refactoring and maintenance should be around 20% of the work in a Sprint. Different viewpoints arise in this area. The author recommends doing such work alongside the normal development activities so long as no high-risk changes are amongst the work being done. For risky changes, leave that until after a major update of the app has been done. There is usually a lull where planning and strategy is developed following a release, which allows a convenient software engineering window to tackle such matters.</p>
<h4 id="ios-quickedit-app-case-study">iOS QuickEdit App Case Study</h4>
<p>Where the analyzer identifies potential crashes, from an economic point of view it is good investment to fix the problem. For example in the case of the QuickEdit iOS App, about 1 million lines of Objective-C, with 70 000 daily active users, the analyzer was run and found 13 clear crashing issues. We created one engineering story (“Fix top analyzer errors”). All 13 issues were fixed in the same day with testing taking two more days. Crashes are a top complaint from customers. Bugs found in the field typically are 20 times the effort and cost compared those found in development. With a large population of users, potentially experiencing a severe crash bug, the cost of those 13 bugs could be 20 * 3 days = 60 days wasted effort.</p>
<p>QuickEdit due to its age only used manual reference counting in Objective-C. Despite this, it had a reliability of 99.5% based on app analytics. Only about 5% of engineering effort was needed to maintain this stability over time once the initial issues had been addressed.</p>
<h3 id="process-methodology">Process Methodology</h3>
<p>One way to drive out crashes from our app, particularly when we are in a large organization, is to factor it in our software development process.</p>
<p>When a developer proposes a code change in a pull request, get the developer to ensure no new analyzer warnings are introduced. We might consider the analyzer report as a robotically generated code review available to us for free. That is particularly helpful if we are working alone on a project with no peer to review our code.</p>
<p>When code is committed to a feature branch, have the automated tests run on it, with different diagnostics settings set. This can shake out problems automatically.</p>
<p>Before each release, schedule time to run some specific user cases under the memory profiler (Xcode instruments will be covered later on) to look at memory usage or other key metrics. Record the highlights such as the peak memory usage as well as the profile file. Then when the following release is made we have a yardstick to see how things have changed both quantitatively and qualitatively.</p>
<h2 id="the-middle-road">The Middle Road</h2>
<p>Most software developers know what they “should” be doing; clean code, proper tests, code reviews, etc.</p>
<p>We recommend taking a measured approach. There is a time for hacking together a sample app to understand a concept. There is a time to write a prototype that just needs to prove a business use case. There is a time to write heavily trusted code used by many people.</p>
<p>We take the view that maximizing economic impact is the one that matters most because most developers are involved in professional software development. Alternatively, if we are working on non-commercial projects or hobby projects, the economic cost is really our personal free time which we will want to use most effectively.</p>
<p>We recommend:</p>
<ul>
<li>For Sample apps and concept exploration, just code the app.</li>
<li>For Prototype Development, just use the Execution Methodology when we hit problems.</li>
<li>For Individual Product Development, from the beginning, run the Analyzer automatically and informally incorporate it into our workflow when we see something important. From the beginning write tests but selectively where we get big impact.</li>
<li>For Team-based Product Development, add in the Process Methodology. Start becoming comprehensive with Testing.</li>
</ul>
<h1 id="hybrid-environments">Hybrid Environments</h1>
<p>We have seen that Xcode offers many automatic facilities for crash dump analysis and crash avoidance. But these can not get us all the answers we need. A complementary design oriented viewpoint is needed.</p>
<p>In this chapter we shall look at a sample app <code>icdab_planets</code> which uses hybrid of programming languages and paradigms. It shows an example of why design insights must also be considered.</p>
<h2 id="program-structure">Program structure</h2>
<p>The <code>icdab_planets</code> sample app uses a mixture of C++, and Objective-C++. It relies on both STL data structures and traditional Objective-C data structures. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<p>The model layer of the app is written in C++. The controller layer of the app is written in Objective-C++.</p>
<p>The purpose of the app is to tell us how many Pluto sized planets would fit inside Jupiter.</p>
<h2 id="paradigms">Paradigms</h2>
<p>Recall earlier we contrasted between Objective-C allowing messaging to nil objects versus C which crashes upon NULL dereference. Here we show how the C++ Standard Template Library has a back-fill strategy.</p>
<p>In the STL map abstraction (a Hash Table) when we query for an entry which does not exist, the STL will insert a new entry in the table for the key being queried, and then return that entry instead of returning an error or returning a nil.</p>
<h2 id="the-problem">The Problem</h2>
<p>In our sample app, which crashes upon launch, we have an assert that gets triggered.</p>
<pre><code>double pluto_volume = pluto.get_volume();
assert(pluto_volume != 0.0);

double plutos_to_fill_jupiter =  jupiter.get_volume() / pluto_volume;</code></pre>
<p>Enabling code Analysis will not find any issue or warning.</p>
<p>The assert is in place to avoid a division by zero. That fact that it is triggered is good because we know where to start debugging the problem.</p>
<p>Pluto’s volume is 0.0 because the code <code>planet pluto = planet::get_planet_with_name(&quot;Pluto&quot;);</code> returns a planet with zero diameter.</p>
<p>From the file <code>planet_data.hpp</code> we see the API that we rely upon is:</p>
<pre><code>static planet get_planet_with_name(string name);</code></pre>
<p>So whatever name we pass in, we should always get a <code>planet</code> in response. Never a NULL.</p>
<p>The problem is that this API has not been thought deeply about. It has just been put together as a thin wrapper around the underlying abstractions that do the work.</p>
<p>We have</p>
<pre><code>planet planet::get_planet_with_name(string name) {
    if (!database.loaded_data) {
        database.load_data();
    }
    return database.planets[name];
}</code></pre>
<p>At first glance it might be that the database failed to load data properly. In actual fact, the database is missing the entry for Pluto due to:</p>
<pre><code>void planet_database::load_data() {
    planet planet_Mercury = planet(&quot;Mercury&quot;, 4878.0, 57.9 * millionKm);
    planets[&quot;Mercury&quot;] = planet_Mercury;

    planet planet_Venus = planet(&quot;Venus&quot;, 12104, 108.2 * millionKm);
    planets[&quot;Venus&quot;] = planet_Venus;

    planet planet_Earth = planet(&quot;Earth&quot;, 12756, 149.6 * millionKm);
    planets[&quot;Earth&quot;] = planet_Earth;

    planet planet_Mars = planet(&quot;Mars&quot;, 6792, 227.9 * millionKm);
    planets[&quot;Mars&quot;] = planet_Mars;

    planet planet_Jupiter = planet(&quot;Jupiter&quot;, 142984, 778 * millionKm);
    planets[&quot;Jupiter&quot;] = planet_Jupiter;

    planet planet_Saturn = planet(&quot;Saturn&quot;, 120536, 1427 * millionKm);
    planets[&quot;Saturn&quot;] = planet_Saturn;

    planet planet_Uranus = planet(&quot;Uranus&quot;, 51118, 2870 * millionKm);
    planets[&quot;Uranus&quot;] = planet_Uranus;

    planet planet_Neptune = planet(&quot;Neptune&quot;, 49532, 4497 * millionKm);
    planets[&quot;Neptune&quot;] = planet_Neptune;

//  No longer considered a planet but instead a dwarf planet
//  planet planet_Pluto = planet(&quot;Pluto&quot;, 2370, 7375 * millionKm);
//  planets[&quot;Pluto&quot;] = planet_Pluto;

    loaded_data = true;
}</code></pre>
<p>The problem indirectly is because <code>database.planets[name]</code> discovered that there was no entry for Pluto so created one via the no-arg constructor as this is the behaviour for STL map data structures.</p>
<pre><code>planet::planet() {
    this-&gt;name = &quot;&quot;;
    this-&gt;diameter = 0.0;
    this-&gt;distance_from_sun = 0.0;
}</code></pre>
<p>We see the constructor makes the diameter zero in this case.</p>
<h2 id="solutions">Solutions</h2>
<p>We see that the problem is not applying the paradigms of each framework and language properly and when we have a mixture of paradigms those different assumptions get masked by each layer of abstraction.</p>
<p>In STL, we expect a <code>find</code> operation to be done, instead of the indexing operator. This allows the abstraction to flag the absence of the item being found.</p>
<p>In Objective-C we expect the lookup API to be a function which returns an index given the lookup name. And the index would be <code>NSNotFound</code> when the operation failed.</p>
<p>In this code example, each layer of abstraction assumes the other side will re-map the edge case into an appropriate form.</p>
<h3 id="stl-solution">STL Solution</h3>
<p>We have a variant of the code which does things “properly” from an STL point of view. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span> It is <code>example/planets_stl</code>. On the consumer side, we have a helper method:</p>
<pre><code>- (BOOL)loadPlanetData {
    auto pluto_by_find = planet::find_planet_named(&quot;Pluto&quot;);
    auto jupiter_by_find = planet::find_planet_named(&quot;Jupiter&quot;);

    if (planet::isEnd(jupiter_by_find) || planet::isEnd(pluto_by_find)) {
        return NO;
    }
    pluto = pluto_by_find-&gt;second;
    jupiter = jupiter_by_find-&gt;second;
    return YES;
}</code></pre>
<p>This is is hard to parse if we are mainly an Objective-C programmer. If the project is mainly a C++ project with a thin platform-specific layer then perhaps that is acceptable. If the code base just leverages C++ code from elsewhere, then a better solution is to confine the paradigms to their own files and apply the facade design pattern to give a version of the API following Objective-C paradigms on the platform-specific code side.</p>
<p>Then Objective-C++ can be dispensed with in the ViewController code; it can be made an Objective-C file instead.</p>
<h3 id="facade-solution">Facade Solution</h3>
<p>Here is a facade implementation <code>example/facade_planets</code> that overcomes the mixing of paradigms problem.</p>
<p>The facade is:</p>
<pre><code>@implementation PlanetModel

- (id)init {
    self = [super init];

    NSString *testSupportAddPluto = [[[NSProcessInfo processInfo] environment]
                                     objectForKey:@&quot;AddPluto&quot;];

    if ([testSupportAddPluto isEqualToString:@&quot;YES&quot;]) {
        planet::add_planet(planet(&quot;Pluto&quot;, 2370, 7375 * millionKm));
    }

    if (self) {
        _planetDict = [[NSMutableDictionary alloc] init];
        auto pluto_by_find = planet::find_planet_named(&quot;Pluto&quot;);
        auto jupiter_by_find = planet::find_planet_named(&quot;Jupiter&quot;);

        if (planet::isEnd(jupiter_by_find) || planet::isEnd(pluto_by_find)) {
            return nil;
        }
        auto pluto = pluto_by_find-&gt;second;
        auto jupiter = jupiter_by_find-&gt;second;

        PlanetInfo *plutoPlanet = [[PlanetInfo alloc] init];
        plutoPlanet.diameter = pluto.get_diameter();
        plutoPlanet.distanceFromSun = pluto.get_distance_from_sun();
        plutoPlanet.volume = pluto.get_volume();
        assert (plutoPlanet.volume != 0.0);
        [_planetDict setObject:plutoPlanet forKey:@&quot;Pluto&quot;];

        PlanetInfo *jupiterPlanet = [[PlanetInfo alloc] init];
        jupiterPlanet.diameter = jupiter.get_diameter();
        jupiterPlanet.distanceFromSun = jupiter.get_distance_from_sun();
        jupiterPlanet.volume = jupiter.get_volume();
        assert (jupiterPlanet.volume != 0.0);
        [_planetDict setObject:jupiterPlanet forKey:@&quot;Jupiter&quot;];
    }

    return self;
}

@end</code></pre>
<p>The consumer then becomes a purely Objective-C class:</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    self.planetModel = [[PlanetModel alloc] init];

    if (self.planetModel == nil) {
        return;
    }

    double pluto_diameter = self.planetModel.planetDict[@&quot;Pluto&quot;].diameter;
    double jupiter_diameter = self.planetModel.planetDict[@&quot;Jupiter&quot;].diameter;
    double plutoVolume = self.planetModel.planetDict[@&quot;Pluto&quot;].volume;
    double jupiterVolume = self.planetModel.planetDict[@&quot;Jupiter&quot;].volume;
    double plutosInJupiter = jupiterVolume/plutoVolume;

    self.plutosInJupiterLabelOutlet.text =
    [NSString stringWithFormat:@&quot;Number of Plutos that fit inside Jupiter = %f&quot;,
     plutosInJupiter];

    self.jupiterLabelOutlet.text =
    [NSString stringWithFormat:@&quot;Diameter of Jupiter (km) = %f&quot;,
     jupiter_diameter];
    self.plutoLabelOutlet.text =
    [NSString stringWithFormat:@&quot;Diameter of Pluto (km) = %f&quot;,
     pluto_diameter];
}</code></pre>
<h2 id="lessons-learnt-1">Lessons Learnt</h2>
<p>The lesson here is that crashes can arise from special case handling. Since different languages and frameworks deal with special cases in their own idiomatic manner, it is safer to separate out our code and use a Facade if possible to keep each paradigm cleanly separated.</p>
<h1 id="symbolification">Symbolification</h1>
<p>This chapter explains crash dump symbolification. We use the <code>icdab_planets</code> sample app to demonstrate a crash. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<p>When dealing with real world crashes, a number of different entities are involved. These can be the end user device, the settings allowing the crash report to be sent back to Apple, the symbols held by Apple and our local development environment setup to mirror such a configuration.</p>
<p>In order to understand how things all fit together it is best to start from first principles and do the data conversion tasks ourselves so if we have to diagnose symbolification issues, we have some experience with the technologies at hand.</p>
<h2 id="build-process">Build Process</h2>
<p>Normally when we develop an app, we are deploying the Debug version of our app onto our device. When we are deploying our app for testers, app review, or app store release, we are deploying the Release version of our app.</p>
<p>In both scenarios debug information is placed into the binary being generated. This is called DWARF debugging information.</p>
<p>For Release builds, that information is then stripped out and placed into a DSYM file. For Debug builds, it is left in.</p>
<p>The debugger can use debugging information in the binary when it sees a crash to help us understand where the program has gone wrong.</p>
<p>When a user sees our program crash, there is no debugger. Instead, a crash report is generated. This comprises the machine addresses where the problem was seen. A later phase, called symbolification, can convert the addresses into meaningful source code references so long as an appropriate DSYM file exists.</p>
<p>Xcode is by default setup so that only DSYM files are generated for Release builds, and not for Debug builds.</p>
<p>The reason why Debug builds just use the application binary with all the debug information built in is that the information is always available and consistent with the rest of the binary. However it makes the binary much larger and allows reverse engineers to peek into our binary quite easily as if we had published the source code together with the program.</p>
<h2 id="build-settings">Build Settings</h2>
<p>From Xcode, in our build settings, searching for “Debug Information Format” we see the following settings:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Setting</th>
<th>Meaning</th>
<th>Usually set for target</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DWARF</td>
<td>Debugging information built into the binary itself</td>
<td>Debug</td>
</tr>
<tr class="even">
<td>DWARF with dSYM File</td>
<td>We get an extra file also generated with symbols</td>
<td>Release</td>
</tr>
</tbody>
</table>
<p>In the default setup, if we run our debug binary on our device, launching it from the app icon itself then if it were to crash we would not have any symbols in the crash report. This confuses many people.</p>
<p>Whilst we may have all the source code for our program, and DWARF data in the crashed binary, ReportCrash crash reporter only looks for DSYM files on our Mac in order to perform symbolification.</p>
<p>To avoid this problem, the sample app <code>icdab_planets</code> has been configured to have <code>DWARF with dSYM File</code> set for both debug and release targets.</p>
<h2 id="observing-a-local-crash">Observing a local crash</h2>
<p>The <code>icdab_planets</code> program is designed to crash upon launch due to an assertion.</p>
<p>If the <code>DWARF with dSYM File</code> setting had not been made, we would get a partially symbolicated crash.</p>
<p>The crash report, seen from Windows-&gt;Devices and Simulators-&gt;View Device Logs, would look like this (truncated for ease of demonstration)</p>
<pre><code>Thread 0 Crashed:
0   libsystem_kernel.dylib          0x0000000183a012ec __pthread_kill + 8
1   libsystem_pthread.dylib         0x0000000183ba2288 pthread_kill$VARIANT$mp + 376
2   libsystem_c.dylib               0x000000018396fd0c abort + 140
3   libsystem_c.dylib               0x0000000183944000 basename_r + 0
4   icdab_planets                   0x00000001008e45bc 0x1008e0000 + 17852
5   UIKit                           0x000000018db56ee0
-[UIViewController loadViewIfRequired] + 1020

Binary Images:
0x1008e0000 - 0x1008ebfff icdab_planets arm64
  &lt;9ff56cfacd66354ea85ff5973137f011&gt;
   /var/containers/Bundle/Application/BEF249D9-1520-40F7-93F4-8B99D913A4AC/
   icdab_planets.app/icdab_planets</code></pre>
<p>However with the setting in place, a crash would instead be reported as:</p>
<pre><code>Thread 0 Crashed:
0   libsystem_kernel.dylib          0x0000000183a012ec __pthread_kill + 8
1   libsystem_pthread.dylib         0x0000000183ba2288
pthread_kill$VARIANT$mp + 376
2   libsystem_c.dylib               0x000000018396fd0c abort + 140
3   libsystem_c.dylib               0x0000000183944000 basename_r + 0
4   icdab_planets                   0x0000000104e145bc
-[PlanetViewController viewDidLoad] + 17852 (PlanetViewController.mm:33)
5   UIKit                           0x000000018db56ee0
-[UIViewController loadViewIfRequired] + 1020</code></pre>
<p>Lines 0, 1, 2, 5 are the same in both cases because our developer environment will have the symbols for the iOS release under test. In the second case Xcode will look up the DSYM file to clarify line 4. It tells us this is line 33 in file PlanetViewController.mm. This is:</p>
<pre><code>assert(pluto_volume != 0.0);</code></pre>
<h2 id="dsym-structure">DSYM structure</h2>
<p>The DSYM file is strictly speaking a directory hierarchy:</p>
<pre><code>icdab_planets.app.dSYM
icdab_planets.app.dSYM/Contents
icdab_planets.app.dSYM/Contents/Resources
icdab_planets.app.dSYM/Contents/Resources/DWARF
icdab_planets.app.dSYM/Contents/Resources/DWARF/icdab_planets
icdab_planets.app.dSYM/Contents/Info.plist</code></pre>
<p>It is just the DWARF data normally put into the debug binary but copied into a separate file.</p>
<p>From looking at our build log we can see how the DSYM was generated. It is effectively just <code>dsymutil path_to_app_binary -o output_symbols_dir.dSYM</code></p>
<h2 id="manual-symbolification">Manual Symbolification</h2>
<p>In order to help us get comfortable with crash dump reports, we can demonstrate how the symbolification actually works. In the first crash dump we want to understand:</p>
<pre><code>4   icdab_planets                   0x00000001008e45bc 0x1008e0000 + 17852</code></pre>
<p>If we knew accurately the version of our code at the time of the crash we can recompile our program but with the DSYM setting switched on and then get a DSYM file after the original crash. It should line up almost exactly.</p>
<p>The crash dump program tells us where the program was loaded in memory at the time of the problem. This is important because it is a master base offset from which all other address (TEXT) locations are relative to. At the bottom of the crash dump we have line <code>0x1008e0000 - 0x1008ebfff icdab_planets</code></p>
<p>So the icdab_planets binary starts at location <code>0x1008e0000</code></p>
<p>Running the lookup command <code>atos</code> symbolicates the line of interest:</p>
<pre><code># atos -arch arm64 -o ./icdab_planets.app.dSYM/Contents/Resources/DWARF/
icdab_planets -l 0x1008e0000 0x00000001008e45bc
-[PlanetViewController viewDidLoad] (in icdab_planets)
 (PlanetViewController.mm:33)</code></pre>
<p>The crash reporter tool fundamentally just uses <code>atos</code> to symbolicate the crash report, as well as providing other system related information.</p>
<p>Symbolification is described further by an Apple Technote in case we want to get into it in more detail. <span class="citation" data-cites="tn2123">(“CrashReport Technote 2123” n.d.)</span></p>
<h2 id="reverse-engineering-approach">Reverse Engineering Approach</h2>
<p>In the above example we have the source code and symbols for the crash dump so can do Symbolification.</p>
<p>Sometimes we may have included a third party binary framework in our project for which we do not have the source code. It is good practice for the vendor to supply symbol information for their framework to allow crash dump analysis. When symbol information is not available, it is still possible to make progress by applying some reverse engineering.</p>
<p>When working with third parties there is typically a much larger turnaround time for diagnostics and troubleshooting. We find that well written and specific bug reports can speed up things a lot. The following approach can help provide the kind of specific information needed.</p>
<p>We shall demonstrate our approach using the Hopper tool mentioned in the Tooling chapter.</p>
<p>Launching hopper, we choose File-&gt;Read Executable to Disassemble. The binary in our case is <code>examples/assert_crash_ios/icdab_planets</code></p>
<p>We need to “rebase” our disassembly so the addresses it shows mirror those of the program when it crashed. We choose Modify-&gt;Change File Base Address. As before, we supply <code>0x1008e0000</code>.</p>
<p>Now we can visit the code which crashed. The address <code>0x00000001008e45bc</code> is actually the address the device would <em>return</em> to after performing the function call in the stack trace. Nevertheless it puts us in the right part of the file. We choose Navigate-&gt;Go To Address or Symbol and supply <code>0x00000001008e45bc</code></p>
<p>The overall view we see is</p>
<p><img src="screenshots/hopperAddressView.png" /></p>
<p>Zooming in on the code line, we have</p>
<p><img src="screenshots/hopperPlanetAbort.png" /></p>
<p>This indeed shows the return address for the assert method. Further up we see the test for Pluto’s volume being non-zero. This is just a very basic Hopper example. We shall revisit Hopper later to demonstrate its most interesting feature - that of being able to generate pseudocode from assembly code. This lowers the mental load of comprehending crashes. Most developers rarely look at assembly code nowadays so this feature is worth the cost of the software itself!</p>
<p>Now at least for the current problem, we could formulate a bug report that said the code was crashing because Pluto’s volume was zero. That may be enough to unlock the problem from the framework vendor’s point of view.</p>
<p>In a more complex case, imagine we were using an image conversion library which was crashing. Since there can be many pixel formats for images, an assert might lead us to notice it was the format that was asserting and we could just try a different pixel format.</p>
<p>Another example would be a security library. Security code often gives back generic error codes, not specific fault codes to allow for future code enhancement and avoid leaking internal details. A crash dump in a security library might point out exactly the kind of security issue, and help us correct some data structure passed into the library much earlier on.</p>
<h1 id="the-crash-report">The Crash Report</h1>
<p>In this chapter we get into the details of what comprises a crash report. Our main focus is the iOS crash report. We also cover the macOS crash report, which caries a slightly different structure but serves the same purpose.</p>
<p>When a crash occurs the <code>ReportCrash</code> program extracts information from the crashing process from the Operating System. The result is a text file with a <code>.crash</code> extension.</p>
<p>When symbol information is available, Xcode will symbolicate the crash report to show symbolic names instead of machine addresses. This improves the comprehensibility of the report.</p>
<p>Apple have a detailed document explaining the anatomy of a crash dump. <span class="citation" data-cites="tn2151">(“Apple Crash Dump Technote 2151” 2018)</span></p>
<h2 id="system-diagnostics">System Diagnostics</h2>
<p>Crash Reports are just one part of a much bigger diagnostic reporting story.</p>
<p>Ordinarily as application developers we don’t need to look much further. However, if our problems are potentially triggered by a unexplained series of events or a more complex system interaction with hardware or Apple provided system services, then not only do we need to look at our crash reports, we need to study the system diagnostics.</p>
<h3 id="extracting-system-diagnostic-information">Extracting System Diagnostic Information</h3>
<p>When understanding the environment that gave rise to our crash, we may need to install Mobile Device Management Profiles (to switch on certain debugging subsystems), or create virtual network interfaces (for network sniffing). Apple have a great web page covering each scenario. <span class="citation" data-cites="apple-sysdiag">(“Diagnostic Profiles and Logs” n.d.)</span></p>
<p>On iOS, the basic idea is that we install a profile which alters our device to produce more logging, then we reproduce the crash (or get the customer to do that). Then we press a special key sequence on the device (for example, both volume buttons and the side button). The system vibrates briefly to indicate it is running a program, <code>sysdiagnose</code> which extracts many log files. Then we use iTunes to sync our device to retrieve the resultant <code>sysdiagnose_date_name.tar.gz</code> file. Inside this archive file are many system and subsystem logs, and we can see when crashes occur and the context that gave rise to them.</p>
<p>An equivalent approach is available on macOS as well.</p>
<h2 id="guided-tour-of-an-ios-crash-report">Guided tour of an iOS Crash Report</h2>
<p>Here we go through each section of an iOS crash report and explain the fields. <span class="citation" data-cites="tn2151">(“Apple Crash Dump Technote 2151” 2018)</span></p>
<p>Note here iOS Crash Report means a crash report that came from a physical target device. After a crash, apps are often debugged on the Simulator. The exception code may be different in that case because the Simulator uses different methodology to cause the app to stop under the debugger.</p>
<h3 id="crash-report-header-section">Crash Report Header Section</h3>
<p>A Crash Report starts with the following header:</p>
<pre><code>Incident Identifier: E030D9E4-32B5-4C11-8B39-C12045CABE26
CrashReporter Key:   b544a32d592996e0efdd7f5eaafd1f4164a2e13c
Hardware Model:      iPad6,3
Process:             icdab_planets [2726]
Path:                /private/var/containers/Bundle/Application/
BEF249D9-1520-40F7-93F4-8B99D913A4AC/icdab_planets.app/icdab_planets
Identifier:          www.perivalebluebell.icdab-planets
Version:             1 (1.0)
Code Type:           ARM-64 (Native)
Role:                Foreground
Parent Process:      launchd [1]
Coalition:           www.perivalebluebell.icdab-planets [1935]</code></pre>
<p>These items are explained by the following table:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Entry</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Incident Identifier</td>
<td>Unique report number of crash</td>
</tr>
<tr class="even">
<td>CrashReporter Key</td>
<td>Unique identifier for the device that crashed</td>
</tr>
<tr class="odd">
<td>Hardware Model</td>
<td>Apple Hardware Model <span class="citation" data-cites="ios-devices">(“List of iOS Devices” 2018)</span></td>
</tr>
<tr class="even">
<td>Process</td>
<td>Process name (number) that crashed</td>
</tr>
<tr class="odd">
<td>Path</td>
<td>Full pathname of crashing program on the device file system</td>
</tr>
<tr class="even">
<td>Identifier</td>
<td>Bundle identifier from <code>Info.plist</code></td>
</tr>
<tr class="odd">
<td>Version</td>
<td>CFBundleVersion; also CFBundleVersionString in brackets</td>
</tr>
<tr class="even">
<td>Code Type</td>
<td>Target architecture of the process that crashed</td>
</tr>
<tr class="odd">
<td>Role</td>
<td>The process <code>task_role</code>. An indicator if we were in the background, foreground, or was a console app. Mainly affects the scheduling priority of the process.</td>
</tr>
<tr class="even">
<td>Parent Process</td>
<td>Which process created the crashing process. <code>launchd</code> is a process launcher and is often the parent.</td>
</tr>
<tr class="odd">
<td>Coalition</td>
<td>Tasks are grouped into coalitions so they can pool together their consumption of resources <span class="citation" data-cites="resource-management">(“Resource Management” 2015)</span></td>
</tr>
</tbody>
</table>
<p>The first thing to look at is the version. Typically if we are a small team or an individual, we will not have the resources to diagnose crashes in older versions of our app, so the first thing might be to get the customer to install the latest version.</p>
<p>If we have got a lot of crashes then we might see it being a problem to one customer (common CrashReporter key seen) or lots of customers (so different CrashReporter keys are seen). This may affect how we rank the priority of the crash.</p>
<p>The hardware model could be interesting. It is iPad only devices, or iPhone only, or both? Maybe our code has less testing or unique code paths for a given platform.</p>
<p>The hardware model might indicate an older device, which we have not tested on.</p>
<p>Whether the app crashed in the Foreground or Background (the Role) is interesting because most applications are not tested when they are backgrounded. For example, we might receive a phone call, or have task switched between apps.</p>
<p>The Code Type (target architecture) is now mostly 64-bit ARM. But we might see ARM being reported - the original 32-bit ARM.</p>
<h3 id="crash-report-date-and-version-section">Crash Report Date and Version Section</h3>
<p>A Crash Report will continue with date and version information:</p>
<pre><code>Date/Time:           2018-07-16 10:15:31.4746 +0100
Launch Time:         2018-07-16 10:15:31.3763 +0100
OS Version:          iPhone OS 11.3 (15E216)
Baseband Version:    n/a
Report Version:      104</code></pre>
<p>These items are explained by the following table:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Entry</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Date/Time</td>
<td>When the crash occurred</td>
</tr>
<tr class="even">
<td>Launch Time</td>
<td>When the process was originally launched before crashing</td>
</tr>
<tr class="odd">
<td>OS Version</td>
<td>Operating System Version (Build number). <span class="citation" data-cites="ios-versions">(“IOS Version History” n.d.)</span></td>
</tr>
<tr class="even">
<td>Baseband Version</td>
<td>Version number of the firmware of the cellular modem (used for phone calls) or <code>n/a</code> if the device has no cellular modem (most iPads, iPod Touch, etc.)</td>
</tr>
<tr class="odd">
<td>Report Version</td>
<td>The version of ReportCrash used to produce the report</td>
</tr>
</tbody>
</table>
<p>The first thing to check is the OS Version. Is it newer or older than we’ve tested? Is it a beta version of the operating system?</p>
<p>The next thing to check is the difference between the launch time and the time of the crash. Did the app crash immediately or after a long time? Early start crashes can sometimes be a packaging and deployment problem. We shall visit some techniques to tackle those later on.</p>
<p>Is the date a sensible value? Sometimes a device is set back or forwards in time, perhaps to trigger date checks on security certificates or license keys. Make sure the date is a realistic looking one.</p>
<p>Normally the baseband version is not interesting. The presence of the baseband means we could get interrupted by a phone call (of course there is VOIP calling as well in any case). iPad software is generally written to assume we’re not going to get a phone call but iPads can be purchased with a cellular modem option.</p>
<h3 id="crash-report-exception-section">Crash Report Exception Section</h3>
<p>A Crash Report will next have exception information:</p>
<pre><code>Exception Type:  EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note:  EXC_CORPSE_NOTIFY
Triggered by Thread:  0</code></pre>
<p>or it may have a more detailed exception information:</p>
<pre><code>Exception Type:  EXC_CRASH (SIGKILL)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note:  EXC_CORPSE_NOTIFY
Termination Reason: Namespace &lt;0xF&gt;, Code 0xdead10cc
Triggered by Thread:  0</code></pre>
<p>What has happened is that the MachOS kernel has raised an Operating System Exception on the problematic process, which terminates the process. The ReportCrash program then retrieves from the OS details of such an exception.</p>
<p>These items are explained by the following table:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Entry</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Exception Type</td>
<td>The type of exception in Mach OS. <span class="citation" data-cites="exception-types">(“Mach Exception Types” n.d.)</span></td>
</tr>
<tr class="even">
<td>Exception Codes</td>
<td>These codes encode the kind of exception, such as trying to trying to access an invalid address, and supporting information. <span class="citation" data-cites="exception-types">(“Mach Exception Types” n.d.)</span></td>
</tr>
<tr class="odd">
<td>Exception Note</td>
<td>Either this says <code>SIMULATED (this is NOT a crash)</code> because the process will killed by the watchdog timer, or it says <code>EXC_CORPSE_NOTIFY</code> because the process crashed</td>
</tr>
<tr class="even">
<td>Termination Reason</td>
<td>Optionally present, this gives a Namespace (number or subsystem name) and a magic number Code (normally a hex number that looks like a English word). See below for details on each Termination Codes.</td>
</tr>
<tr class="odd">
<td>Triggered by Thread</td>
<td>The thread in the process that caused the crash</td>
</tr>
</tbody>
</table>
<p>In this section the most important item is the exception type.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Exception Type</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>EXC_CRASH (SIGABRT)</code></td>
<td>Our program raised a programming language exception such as a failed assertion and this caused the OS to Abort our app</td>
</tr>
<tr class="even">
<td><code>EXC_CRASH (SIGQUIT)</code></td>
<td>A process received a quit signal from another process that is managing it. Typically this means a Keyboard extension took too long or used up too much memory. App extensions are only only limited amounts of memory.</td>
</tr>
<tr class="odd">
<td><code>EXC_CRASH (SIGKILL)</code></td>
<td>The system killed our app (or app extension), usually because some resource limit had been reached. The Termination Reason needs to be looked at to work out what policy violation was the reason for termination.</td>
</tr>
<tr class="even">
<td><code>EXC_BAD_ACCESS</code> or <code>SIGSEGV</code> or <code>SIGBUS</code></td>
<td>Our program most likely tried to access a bad memory location or the address was good but we did not have the privilege to access it. The memory might have been deallocated due to due memory pressure.</td>
</tr>
<tr class="odd">
<td><code>EXC_BREAKPOINT (SIGTRAP)</code></td>
<td>This is due to an <code>NSException</code> being raised (possibly by a library on our behalf) or <code>_NSLockError</code> or <code>objc_exception_throw</code> being called. For example, this can be the Swift environment detecting an anomaly such as force unwrapping a nil optional</td>
</tr>
<tr class="even">
<td>EXC_BAD_INSTRUCTION (SIGILL)</td>
<td>This is when the program code itself is faulty, not the memory it might be accessing. This should be rare on iOS devices; a compiler or optimiser bug, or faulty hand written assembly code. On Simulator it is a different story as using an undefined opcode is a technique used by the Swift runtime to stop on access to zombie objects (deallocated objects).</td>
</tr>
</tbody>
</table>
<p>When Termination Reason is present, we can look up the Code as follows:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Termination Code</th>
<th>Spoken As</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0xdead10cc</code></td>
<td>Deadlock</td>
<td>We held a file lock or sqlite database lock before suspending. We should release locks before suspending.</td>
</tr>
<tr class="even">
<td><code>0xbaaaaaad</code></td>
<td>Bad</td>
<td>A stackshot was done of the entire system via the side and both volume buttons. See earlier section on System Diagnostics</td>
</tr>
<tr class="odd">
<td><code>0xbad22222</code></td>
<td>Bad too (two) many times</td>
<td>VOIP was terminated as it resumed too frequently. Also see with code using networking whilst in the background. If our TCP connection is woken up too many times (say 15 wakes in 300 seconds) we get this crash.</td>
</tr>
<tr class="even">
<td><code>0x8badf00d</code></td>
<td>Ate (eight) bad food</td>
<td>Our app took too long to perform a state change (starting up, shutting down, handling system message, etc.). The watchdog timer noticed the policy violation and caused the termination. The most common culprit is doing synchronous networking on the main thread.</td>
</tr>
<tr class="odd">
<td><code>0xc00010ff</code></td>
<td>Cool Off</td>
<td>The system detected a thermal event and kill off our app. If it’s just one device it could be a hardware issue, not a software problem in our app. If it happens on other devices, check our app’s power usage using Instruments.</td>
</tr>
<tr class="even">
<td><code>0x2bad45ec</code></td>
<td>Too bad for security</td>
<td>There was a security violation. If the Termination Description says “Process detected doing insecure drawing while in secure mode” it means our app tried to write to the screen when it was not allowed because for example the Lock Screen was being shown.</td>
</tr>
</tbody>
</table>
<h4 id="aborts">Aborts</h4>
<p>When we have a <code>SIGABRT</code> , we should look for what exceptions and assertions are present in our code from the stack trace of the crashed thread.</p>
<h4 id="memory-issues">Memory Issues</h4>
<p>When we have a memory issue, <code>EXC_BAD_ACCESS</code> , <code>SIGSEGV</code> or <code>SIGBUS</code>. The faulty memory reference is the second number of the Exception Codes number pair. For this type of problem, the diagnostics settings within Xcode for the target in the schema are relevant. The address sanitiser should be switched on to see if it can spot the error. If that cannot detect the issue, try each of the memory management settings, one at a time.</p>
<p>If Xcode shows a lot of memory is being used by the app, then it might be that memory we were relying upon has been freed by the system. For this, switch on the Malloc Stack logging option, selecting All Allocation and Free History. Then at some point during the app, the MemGraph button can be clicked, and then the allocation history of objects explored.</p>
<h4 id="exceptions">Exceptions</h4>
<p>When we have a <code>EXC_BREAKPOINT</code> it can seem confusing. The program may have been running standalone without a debugger so where did the breakpoint come from? Typically we are running <code>NSException</code> code. This will make the system signal the process with the trace trap signal and this makes any available debugger attach to the process to aid debugging. So in the case where we were running the app under the debugger, even with breakpoints switched off, we would breakpoint in here so we can find out why there was a runtime exception. In the case of normal app running, there is no debugger so we would just crash the app.</p>
<h4 id="illegal-instructions">Illegal Instructions</h4>
<p>When we have a <code>EXC_BAD_INSTRUCTION</code> , the exception codes (second number) will be the problematic assembly code. This should be a rare condition. It is worthwhile adjusting the optimisation level of the code at fault in the Build Settings because higher level optimisations can cause more exotic instructions to be emitted during build time, and hence a bigger chance for a compiler bug. Alternatively the problem might be a lower level library which has hand assembly optimisations in it - such as a multimedia library. Handwritten assembly can be the cause of bad instructions.</p>
<h3 id="crash-report-filtered-syslog-section">Crash Report Filtered Syslog Section</h3>
<p>The Crash Report continues with the syslog section:</p>
<pre><code>Filtered syslog:
None found</code></pre>
<p>This is an anomalous section because it is supposed to look at the process ID of the crashed process and then look to see if there are any syslog (System Log) entries for that process. We have never seen filtered entries in a crash, and only see <code>None found</code> reported.</p>
<h3 id="crash-report-thread-section">Crash Report Thread Section</h3>
<p>The Crash Report continues with a dump of the thread backtraces as follows (formatted for ease of demonstration)</p>
<pre><code>Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libsystem_kernel.dylib          0x0000000183a012ec
 __pthread_kill + 8
1   libsystem_pthread.dylib         0x0000000183ba2288
 pthread_kill$VARIANT$mp + 376
2   libsystem_c.dylib               0x000000018396fd0c
 abort + 140
3   libsystem_c.dylib               0x0000000183944000
 basename_r + 0
4   icdab_planets                   0x0000000104e145bc
 -[PlanetViewController viewDidLoad] + 17852 (PlanetViewController.mm:33)
5   UIKit                           0x000000018db56ee0
 -[UIViewController loadViewIfRequired] + 1020
6   UIKit                           0x000000018db56acc
 -[UIViewController view] + 28
7   UIKit                           0x000000018db47d60
 -[UIWindow addRootViewControllerViewIfPossible] + 136
8   UIKit                           0x000000018db46b94
 -[UIWindow _setHidden:forced:] + 272
9   UIKit                           0x000000018dbd46a8
-[UIWindow makeKeyAndVisible] + 48
10  UIKit                           0x000000018db4a2f0
 -[UIApplication _callInitializationDelegatesForMainScene:transitionContext:]
  + 3660
11  UIKit                           0x000000018db1765c
-[UIApplication _runWithMainScene:transitionContext:completion:] + 1680
12  UIKit                           0x000000018e147a0c
__111-[__UICanvasLifecycleMonitor_Compatability
_scheduleFirstCommitForScene:transition:firstActivation:
completion:]_block_invoke + 784
13  UIKit                           0x000000018db16e4c
+[_UICanvas _enqueuePostSettingUpdateTransactionBlock:] + 160
14  UIKit                           0x000000018db16ce8
-[__UICanvasLifecycleMonitor_Compatability
_scheduleFirstCommitForScene:transition:firstActivation:completion:] + 240
15  UIKit                           0x000000018db15b78
-[__UICanvasLifecycleMonitor_Compatability
activateEventsOnly:withContext:completion:] + 724
16  UIKit                           0x000000018e7ab72c
__82-[_UIApplicationCanvas _transitionLifecycleStateWithTransitionContext:
completion:]_block_invoke + 296
17  UIKit                           0x000000018db15268
-[_UIApplicationCanvas _transitionLifecycleStateWithTransitionContext:
completion:] + 432
18  UIKit                           0x000000018e5909b8
__125-[_UICanvasLifecycleSettingsDiffAction performActionsForCanvas:
withUpdatedScene:settingsDiff:fromSettings:
transitionContext:]_block_invoke + 220
19  UIKit                           0x000000018e6deae8
_performActionsWithDelayForTransitionContext + 112
20  UIKit                           0x000000018db14c88
-[_UICanvasLifecycleSettingsDiffAction performActionsForCanvas:withUpdatedScene:
settingsDiff:fromSettings:transitionContext:] + 248
21  UIKit                           0x000000018db14624
-[_UICanvas scene:didUpdateWithDiff:transitionContext:completion:] + 368
22  UIKit                           0x000000018db1165c
-[UIApplication workspace:didCreateScene:withTransitionContext:completion:]
 + 540
23  UIKit                           0x000000018db113ac
-[UIApplicationSceneClientAgent scene:didInitializeWithEvent:completion:] + 364
24  FrontBoardServices              0x0000000186778470
-[FBSSceneImpl _didCreateWithTransitionContext:completion:] + 364
25  FrontBoardServices              0x0000000186780d6c
__56-[FBSWorkspace client:handleCreateScene:withCompletion:]_block_invoke_2 + 224
26  libdispatch.dylib               0x000000018386cae4
_dispatch_client_callout + 16
27  libdispatch.dylib               0x00000001838741f4
_dispatch_block_invoke_direct$VARIANT$mp + 224
28  FrontBoardServices              0x00000001867ac878
__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 36
29  FrontBoardServices              0x00000001867ac51c
-[FBSSerialQueue _performNext] + 404
30  FrontBoardServices              0x00000001867acab8
-[FBSSerialQueue _performNextFromRunLoopSource] + 56
31  CoreFoundation                  0x0000000183f23404
__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24
32  CoreFoundation                  0x0000000183f22c2c
__CFRunLoopDoSources0 + 276
33  CoreFoundation                  0x0000000183f2079c __CFRunLoopRun + 1204
34  CoreFoundation                  0x0000000183e40da8
CFRunLoopRunSpecific + 552
35  GraphicsServices                0x0000000185e23020 GSEventRunModal + 100
36  UIKit                           0x000000018de2178c UIApplicationMain + 236
37  icdab_planets                   0x0000000104e14c94 main + 19604 (main.m:14)
38  libdyld.dylib                   0x00000001838d1fc0 start + 4

Thread 1:
0   libsystem_pthread.dylib         0x0000000183b9fb04 start_wqthread + 0

Thread 2:
0   libsystem_kernel.dylib          0x0000000183a01d84 __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000183b9feb4 _pthread_wqthread + 928
2   libsystem_pthread.dylib         0x0000000183b9fb08 start_wqthread + 4

Thread 3:
0   libsystem_pthread.dylib         0x0000000183b9fb04 start_wqthread + 0

Thread 4:
0   libsystem_kernel.dylib          0x0000000183a01d84 __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000183b9feb4 _pthread_wqthread + 928
2   libsystem_pthread.dylib         0x0000000183b9fb08 start_wqthread + 4

Thread 5:
0   libsystem_kernel.dylib          0x0000000183a01d84 __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000183b9feb4 _pthread_wqthread + 928
2   libsystem_pthread.dylib         0x0000000183b9fb08 start_wqthread + 4

Thread 6 name:  com.apple.uikit.eventfetch-thread
Thread 6:
0   libsystem_kernel.dylib          0x00000001839dfe08 mach_msg_trap + 8
1   libsystem_kernel.dylib          0x00000001839dfc80 mach_msg + 72
2   CoreFoundation                  0x0000000183f22e40
__CFRunLoopServiceMachPort + 196
3   CoreFoundation                  0x0000000183f20908 __CFRunLoopRun + 1568
4   CoreFoundation                  0x0000000183e40da8
CFRunLoopRunSpecific + 552
5   Foundation                      0x00000001848b5674
-[NSRunLoop+ 34420 (NSRunLoop) runMode:beforeDate:] + 304
6   Foundation                      0x00000001848b551c
-[NSRunLoop+ 34076 (NSRunLoop) runUntilDate:] + 148
7   UIKit                           0x000000018db067e4
-[UIEventFetcher threadMain] + 136
8   Foundation                      0x00000001849c5efc
__NSThread__start__ + 1040
9   libsystem_pthread.dylib         0x0000000183ba1220 _pthread_body + 272
10  libsystem_pthread.dylib         0x0000000183ba1110 _pthread_body + 0
11  libsystem_pthread.dylib         0x0000000183b9fb10 thread_start + 4

Thread 7:
0   libsystem_pthread.dylib         0x0000000183b9fb04 start_wqthread + 0</code></pre>
<p>The crash report will explicitly tell us which thread crashed.</p>
<pre><code>Thread 0 Crashed:</code></pre>
<p>Threads are numbered, and if they have a name we are told this:</p>
<pre><code>Thread 0 name:  Dispatch queue: com.apple.main-thread</code></pre>
<p>Most of our focus should be on the crashed thread; it is often thread 0. Take note of the thread name. Note no long duration tasks such as networking may be done on the main thread, <code>com.apple.main-thread</code>, because that thread is used to handle user interactions.</p>
<p>The references to <code>__workq_kernreturn</code> just indicate a thread waiting for work so can be ignored unless there are a huge number of them.</p>
<p>Similarly the reference to <code>mach_msg_trap</code> just indicate waiting for a message to come in.</p>
<p>When looking at stack backtraces, stack frame 0, the top of the stack, comes first, and then calling frames are listed. So the last thing being done is in frame 0. The frame number is the first number in the stack backtrace line for a given thread. The second frame, numbered 1, is code that called the function being executed in stack frame 0. This repeats until reach the original code that was running when the thread commenced.</p>
<p>The second column in a back trace is the binary file. We focus on our own binary mostly because framework code from Apple is generally very reliable. Faults usually occur either directly in our code, or by faults caused by incorrect usage of Apple APIs. Just because the code crashed in Apple provided code does not mean the fault is in Apple code.</p>
<p>The fourth column onwards is the address in memory after the code from the higher up stacks would leave the program once they have returned to the particular stack frame in question. If in our binary, and our libraries we do not see a symbolic address, but just hex offsets, then we have not got a symbolicated crash report. See earlier chapter on Symbolification.</p>
<p>The fifth column is the calling function relative to the parent function it is in. The plus sign followed by an offset tells us how far into the parent function the call to the next function is.</p>
<p>Therefore with the example stack frame:</p>
<pre><code>20  UIKit                           0x000000018db14c88
-[_UICanvasLifecycleSettingsDiffAction performActionsForCanvas:withUpdatedScene:
settingsDiff:fromSettings:transitionContext:] + 248</code></pre>
<p>We see :</p>
<h1 id="a-siri-crash">A Siri Crash</h1>
<h2 id="why-are-we-looking-at-a-siri-crash">Why are we looking at a Siri Crash?</h2>
<p>Here is an example of Siri crashing on a Mac. Note that binaries on a Mac are not encrypted. This means we can demonstrate the use of third party tools to explore the binaries at fault. Since only Apple has the source code for Siri, it adds to the challenge and forces us think abstractly about the problem.</p>
<h2 id="the-crash-report-1">The Crash report</h2>
<p>Here is the crash report, suitably truncated for ease of demonstration:</p>
<pre><code>Process:               SiriNCService [1045]
Path:                  
/System/Library/CoreServices/Siri.app/Contents/XPCServices/SiriNCService.xpc/
Contents/MacOS/SiriNCService
Identifier:            com.apple.SiriNCService
Exception Type:        EXC_BAD_ACCESS (SIGSEGV)
Exception Codes:       KERN_INVALID_ADDRESS at 0x0000000000000018
Exception Note:        EXC_CORPSE_NOTIFY
VM Regions Near 0x18:
--&gt;
    __TEXT                 0000000100238000-0000000100247000
    [   60K] r-x/rwx SM=COW  /System/Library/CoreServices/Siri.app/Contents/
    XPCServices/SiriNCService.xpc/Contents/MacOS/SiriNCService

Application Specific Information:
objc_msgSend() selector name: didUnlockScreen:

Thread 0 Crashed:: Dispatch queue: com.apple.main-thread
0   libobjc.A.dylib                 0x00007fff69feae9d objc_msgSend + 29
1   com.apple.CoreFoundation        0x00007fff42e19f2c
 __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 12
2   com.apple.CoreFoundation        0x00007fff42e19eaf
___CFXRegistrationPost_block_invoke + 63
3   com.apple.CoreFoundation        0x00007fff42e228cc
 __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
4   com.apple.CoreFoundation        0x00007fff42e052a3 __CFRunLoopDoBlocks + 275
5   com.apple.CoreFoundation        0x00007fff42e0492e __CFRunLoopRun + 1278
6   com.apple.CoreFoundation        0x00007fff42e041a3
CFRunLoopRunSpecific + 483
7   com.apple.HIToolbox             0x00007fff420ead96
RunCurrentEventLoopInMode + 286
8   com.apple.HIToolbox             0x00007fff420eab06
ReceiveNextEventCommon + 613
9   com.apple.HIToolbox             0x00007fff420ea884
_BlockUntilNextEventMatchingListInModeWithFilter + 64
10  com.apple.AppKit                0x00007fff4039ca73 _DPSNextEvent + 2085
11  com.apple.AppKit                0x00007fff40b32e34
-[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 3044
12  com.apple.ViewBridge            0x00007fff67859df0
-[NSViewServiceApplication nextEventMatchingMask:untilDate:inMode:dequeue:] + 92
13  com.apple.AppKit                0x00007fff40391885 -[NSApplication run] + 764
14  com.apple.AppKit                0x00007fff40360a72 NSApplicationMain + 804
15  libxpc.dylib                    0x00007fff6af6cdc7 _xpc_objc_main + 580
16  libxpc.dylib                    0x00007fff6af6ba1a xpc_main + 433
17  com.apple.ViewBridge            0x00007fff67859c15
-[NSXPCSharedListener resume] + 16
18  com.apple.ViewBridge            0x00007fff67857abe
NSViewServiceApplicationMain + 2903
19  com.apple.SiriNCService         0x00000001002396e0 main + 180
20  libdyld.dylib                   0x00007fff6ac12015 start + 1</code></pre>
<h2 id="the-crash-details">The Crash details</h2>
<p>Looking at the 09:52 crash we see</p>
<p><code>Exception Type:        EXC_BAD_ACCESS (SIGSEGV)</code></p>
<p>This means we are accessing memory which does not exist. The program that was running (known as the TEXT) was</p>
<pre><code>/System/Library/CoreServices/Siri.app/Contents/XPCServices/SiriNCService.xpc/
Contents/MacOS/SiriNCService</code></pre>
<p>This is interesting because normally its applications that crash. Here we see a software component crashing. The Siri service is a distributed app which uses cross process communication (xpc) to do its work. We see that from references to xpc as above.</p>
<p>What method were we trying to call on an object that no longer exists? Helpfully, the crash dump provides the answer:</p>
<p><code>Application Specific Information: objc_msgSend() selector name: didUnlockScreen:</code></p>
<p>Now we have to a first level approximation answered the <em>what</em>, <em>where</em> and <em>when</em> aspect of the crash. It was a Siri component that crashed, in <code>SiriNCService</code> when <code>didUnlockScreen</code> was called on a non-existent object.</p>
<h2 id="applying-our-tool-box">Applying our Tool Box</h2>
<p>Now to understand further we need to reach for the <code>class-dump</code> tool.</p>
<p><code>class-dump SiriNCService &gt; SiriNCService.classdump.txt</code></p>
<p>Looking at a portion of the output is the following:</p>
<pre><code>@property __weak SiriNCService *service; // @synthesize service=_service;
- (void).cxx_destruct;
- (BOOL)isSiriListening;
- (void)_didUnlockScreen:(id)arg1;
- (void)_didLockScreen:(id)arg1;</code></pre>
<p>We see that there is indeed a method, <code>didUnlockScreen</code>, and we see that there is a service object which is owned <strong>weakly</strong>. This means that the object is not retained and could get freed. It typically means we a user of the <code>SiriNCService</code> but not the owner. We do not own the lifecycle of the object.</p>
<h2 id="software-engineering-insights">Software Engineering Insights</h2>
<p>The underlying software engineering problem here is one of lifecycle. Part of the application has a object lifecycle we were not expecting. The consumer should have been written to detect the absence of the service as a robustness and defensive programming best practice. What can happen is that the software is maintained over time, and the lifecycles of objects grow more complex over time as new functionality is added but the old code using the objects is not updated in sync.</p>
<p>Taking one step further back we should ask what weak properties are used by this component? From that we can create some simple unit test cases which test the code whilst those objects are nil. Then we can go back and add robustness to the code paths that assumed the object were non-nil.</p>
<p>Taking a further step back, is there anything unusual in the design of this component that calls for integration testing?</p>
<pre><code>grep -i heat SiriNCService.classdump.txt
@protocol SiriUXHeaterDelegate &lt;NSObject&gt;
- (void)heaterSuggestsPreheating:(SiriUXHeater *)arg1;
- (void)heaterSuggestsDefrosting:(SiriUXHeater *)arg1;
@interface SiriNCAlertViewController : NSViewController
&lt;SiriUXHeaterDelegate, AFUISiriViewControllerDataSource,
 AFUISiriViewControllerDelegate&gt;
    SiriUXHeater *_heater;
@property(readonly, nonatomic)
SiriUXHeater *heater; // @synthesize heater=_heater;
- (void)heaterSuggestsPreheating:(id)arg1;
- (void)heaterSuggestsDefrosting:(id)arg1;
@interface SiriUXHeater : NSObject
    id &lt;SiriUXHeaterDelegate&gt; _delegate;
@property(nonatomic)
__weak id &lt;SiriUXHeaterDelegate&gt; delegate; // @synthesize delegate=_delegate;
- (void)_suggestPreheat;</code></pre>
<p>It seems that this component can be prepared and made ready and has a variety of levels of initialisation and de-initialisation. Maybe this complexity is to make the user interface responsive. But it sends us a message that this component needs an integration test suite that codifies the state machine so we know the lifecycle of the service.</p>
<h2 id="lessons-learnt-2">Lessons Learnt</h2>
<p>We went from using HOWTO knowledge (understanding the crash report) to using tooling to get a baseline level of knowledge. Then we started to apply Software Engineering experiences, and then we started reasoning about the actual design of the component to ask how we got here and what should be done to avoid the problem. This journey from looking at the artefacts of a problem to getting to the root of what needs to be done is a common theme during crash dump analysis. It cannot be achieved by just focusing on the HOWTO of comprehending crash reports. We need to switch hats and see things from different perspectives in order to really make progress.</p>
<h1 id="bibliography" class="unnumbered">Bibliography</h1>
<div id="refs" class="references">
<div id="ref-tn2151">
<p>“Apple Crash Dump Technote 2151.” 2018. <a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html" class="uri">https://developer.apple.com/library/archive/technotes/tn2151/_index.html</a>.</p>
</div>
<div id="ref-tn2123">
<p>“CrashReport Technote 2123.” n.d. Accessed 2004.</p>
</div>
<div id="ref-apple-sysdiag">
<p>“Diagnostic Profiles and Logs.” n.d. Accessed 2018.</p>
</div>
<div id="ref-icdabgithub">
<p>“IOS Crash Dump Analysis Book Github Resources.” 2018. <a href="https://github.com/faisalmemon/ios-crash-dump-analysis-book" class="uri">https://github.com/faisalmemon/ios-crash-dump-analysis-book</a>.</p>
</div>
<div id="ref-ios-versions">
<p>“IOS Version History.” n.d. Accessed 2018.</p>
</div>
<div id="ref-ios-devices">
<p>“List of iOS Devices.” 2018. <a href="https://en.wikipedia.org/wiki/List_of_iOS_devices" class="uri">https://en.wikipedia.org/wiki/List_of_iOS_devices</a>.</p>
</div>
<div id="ref-exception-types">
<p>“Mach Exception Types.” n.d. Accessed 2018.</p>
</div>
<div id="ref-class-dump-tool">
<p>Nygard, Steve. 2018. “Class Dump Tool.” <a href="http://stevenygard.com/projects/class-dump/" class="uri">http://stevenygard.com/projects/class-dump/</a>.</p>
</div>
<div id="ref-panicbook">
<p><em>Panic! Unix System Crash Dump Analysis</em>. 1995. 1st ed. Vol. 1. 0-13-149386-8. Prentice Hall.</p>
</div>
<div id="ref-resource-management">
<p>“Resource Management.” 2015. <a href="http://newosxbook.com/files/MSAse2015.pdf" class="uri">http://newosxbook.com/files/MSAse2015.pdf</a>.</p>
</div>
</div>
</body>
</html>
